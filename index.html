<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>DEEP — A Descent into Darkness</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;600;700&family=Cinzel:wght@400;700&family=Crimson+Text:ital,wght@0,400;0,600;1,400&display=swap');

  :root {
    --bg-void: #08080c;
    --bg-dark: #0e0e18;
    --bg-surface: #14142a;
    --bg-elevated: #1a1a38;
    --wall: #3a3a5c;
    --wall-lit: #5a5a8c;
    --floor: #2a2a44;
    --floor-lit: #4a4a6e;
    --player: #f0c040;
    --player-glow: #f0c04066;
    --monster-common: #cc4444;
    --monster-rare: #cc44cc;
    --monster-boss: #ff4444;
    --item-common: #44aacc;
    --item-magic: #aa44ff;
    --item-gold: #f7931a;
    --stairs: #ffffff;
    --hp-full: #44cc44;
    --hp-warn: #cccc44;
    --hp-danger: #cc4444;
    --mana: #4488ff;
    --xp: #cc88ff;
    --text-bright: #e0e0f0;
    --text-dim: #6a6a8e;
    --text-faded: #3a3a5c;
    --accent: #f08030;
    --accent-glow: #f0803044;
    --border: #2a2a4a;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg-void);
    color: var(--text-bright);
    font-family: 'Fira Code', monospace;
    overflow: hidden;
    user-select: none;
    width: 100vw;
    height: 100vh;
  }

  /* Scanline overlay */
  body::after {
    content: '';
    position: fixed;
    inset: 0;
    background: repeating-linear-gradient(0deg, transparent 0px, rgba(0,0,0,0.03) 1px, transparent 2px);
    pointer-events: none;
    z-index: 1000;
  }

  /* Vignette */
  body::before {
    content: '';
    position: fixed;
    inset: 0;
    background: radial-gradient(ellipse at center, transparent 40%, rgba(0,0,0,0.6) 100%);
    pointer-events: none;
    z-index: 999;
  }

  /* ── GAME LAYOUT ── */
  .game-layout {
    display: grid;
    grid-template-columns: 210px 1fr 170px;
    grid-template-rows: 34px 1fr 180px;
    grid-template-areas:
      "title  title   title"
      "stats  map     sidebar"
      "stats  log     sidebar";
    width: 100vw;
    height: 100vh;
    gap: 1px;
    background: var(--border);
  }

  .panel {
    background: var(--bg-dark);
    overflow: hidden;
  }

  /* Title bar */
  #title-bar {
    grid-area: title;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0 16px;
    font-family: 'Cinzel', serif;
    font-size: 13px;
    color: var(--text-dim);
    letter-spacing: 2px;
    text-transform: uppercase;
    border-bottom: 1px solid var(--border);
  }
  #title-bar .floor-name { color: var(--accent); }
  #title-bar .turn-count { font-family: 'Fira Code', monospace; font-size: 11px; }

  /* Stats panel */
  #stats-panel {
    grid-area: stats;
    padding: 12px;
    font-size: 12px;
    overflow-y: auto;
    border-right: 1px solid var(--border);
  }
  #stats-panel h2 {
    font-family: 'Cinzel', serif;
    font-size: 14px;
    color: var(--player);
    margin-bottom: 4px;
    letter-spacing: 1px;
  }
  #stats-panel .class-race {
    font-size: 11px;
    color: var(--text-dim);
    margin-bottom: 10px;
    font-style: italic;
    font-family: 'Crimson Text', serif;
  }

  .bar-container {
    margin-bottom: 6px;
  }
  .bar-label {
    display: flex;
    justify-content: space-between;
    font-size: 10px;
    color: var(--text-dim);
    margin-bottom: 2px;
  }
  .bar-track {
    height: 8px;
    background: var(--bg-void);
    border-radius: 2px;
    overflow: hidden;
  }
  .bar-fill {
    height: 100%;
    border-radius: 2px;
    transition: width 0.3s ease, background-color 0.3s ease;
  }
  .bar-fill.hp { background: var(--hp-full); }
  .bar-fill.hp.warn { background: var(--hp-warn); }
  .bar-fill.hp.danger { background: var(--hp-danger); }
  .bar-fill.mana { background: var(--mana); }
  .bar-fill.xp { background: var(--xp); }

  .stat-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 2px 8px;
    margin: 10px 0;
    font-size: 11px;
  }
  .stat-grid .stat-name { color: var(--text-dim); }
  .stat-grid .stat-val { color: var(--text-bright); }
  .stat-grid .stat-mod { font-size: 10px; }
  .stat-grid .stat-mod.pos { color: var(--hp-full); }
  .stat-grid .stat-mod.neg { color: var(--hp-danger); }

  .equip-section { margin-top: 10px; font-size: 11px; }
  .equip-section h3 {
    font-family: 'Cinzel', serif;
    font-size: 11px;
    color: var(--text-dim);
    margin-bottom: 4px;
    letter-spacing: 1px;
  }
  .equip-slot {
    color: var(--text-faded);
    margin-bottom: 2px;
  }
  .equip-slot .item-name { color: var(--item-common); }
  .equip-slot .item-magic { color: var(--item-magic); }

  .conditions { margin-top: 8px; font-size: 10px; }
  .cond-badge {
    display: inline-block;
    padding: 1px 5px;
    border-radius: 3px;
    margin: 1px;
    font-size: 9px;
  }
  .cond-badge.buff { background: #1a3a1a; color: var(--hp-full); }
  .cond-badge.debuff { background: #3a1a1a; color: var(--hp-danger); }

  /* Dungeon map */
  #map-panel {
    grid-area: map;
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--bg-void);
    overflow: hidden;
  }
  #dungeon-map {
    font-family: 'Fira Code', monospace;
    font-size: 15px;
    line-height: 1.2;
    white-space: pre;
    letter-spacing: 0.5px;
  }

  /* Map tile classes */
  .t-void { color: transparent; }
  .t-wall { color: var(--wall-lit); }
  .t-floor { color: var(--floor-lit); }
  .t-door { color: #aa8844; }
  .t-stairs { color: var(--stairs); font-weight: bold; }
  .t-trap { color: #cc6644; }
  .t-water { color: #4488aa; }
  .t-player {
    color: var(--player);
    font-weight: bold;
    animation: torchFlicker 1.5s ease-in-out infinite;
  }

  @keyframes torchFlicker {
    0%   { text-shadow: 0 0 8px var(--player-glow), 0 0 20px var(--player-glow); }
    25%  { text-shadow: 0 0 12px var(--player-glow), 0 0 30px var(--player-glow); }
    50%  { text-shadow: 0 0 6px var(--player-glow), 0 0 16px var(--player-glow); }
    75%  { text-shadow: 0 0 14px var(--player-glow), 0 0 28px var(--player-glow); }
    100% { text-shadow: 0 0 8px var(--player-glow), 0 0 20px var(--player-glow); }
  }

  /* Sidebar */
  #sidebar {
    grid-area: sidebar;
    padding: 10px;
    font-size: 11px;
    border-left: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    gap: 10px;
  }
  #mini-map-container {
    border: 1px solid var(--border);
    background: var(--bg-void);
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 4px;
  }
  #mini-map {
    image-rendering: pixelated;
  }
  .action-hints h3 {
    font-family: 'Cinzel', serif;
    font-size: 10px;
    color: var(--text-dim);
    letter-spacing: 1px;
    margin-bottom: 6px;
  }
  .hint-line {
    color: var(--text-faded);
    margin-bottom: 3px;
    font-size: 10px;
  }
  .hint-line kbd {
    color: var(--accent);
    font-weight: bold;
  }

  /* Message log */
  #log-panel {
    grid-area: log;
    padding: 8px 12px;
    overflow-y: auto;
    font-size: 12px;
    line-height: 1.5;
    border-top: 1px solid var(--border);
  }
  #log-panel::-webkit-scrollbar { width: 4px; }
  #log-panel::-webkit-scrollbar-track { background: var(--bg-dark); }
  #log-panel::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

  .log-entry { margin-bottom: 2px; }
  .log-entry.narrative { font-family: 'Crimson Text', serif; font-style: italic; color: var(--text-dim); font-size: 13px; }
  .log-hit { color: var(--hp-full); }
  .log-miss { color: var(--text-faded); }
  .log-damage { color: var(--accent); }
  .log-kill { color: var(--player); }
  .log-player-hit { color: var(--hp-danger); }
  .log-xp { color: var(--xp); }
  .log-item { color: var(--item-common); }
  .log-gold { color: var(--item-gold); }
  .log-info { color: var(--text-dim); }

  /* ── OVERLAYS ── */
  .overlay {
    position: fixed;
    inset: 0;
    background: rgba(8, 8, 12, 0.95);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 100;
  }
  .overlay.hidden { display: none; }

  /* Title screen */
  #title-screen {
    text-align: center;
  }
  #title-screen .ascii-title {
    font-family: 'Fira Code', monospace;
    font-size: 14px;
    color: var(--accent);
    line-height: 1.15;
    margin-bottom: 20px;
    animation: titleGlow 3s ease-in-out infinite;
  }
  @keyframes titleGlow {
    0%, 100% { text-shadow: 0 0 10px var(--accent-glow), 0 0 30px var(--accent-glow); filter: brightness(1); }
    50% { text-shadow: 0 0 20px var(--accent-glow), 0 0 50px var(--accent-glow); filter: brightness(1.15); }
  }
  #title-screen .subtitle {
    font-family: 'Crimson Text', serif;
    font-style: italic;
    font-size: 20px;
    color: var(--text-dim);
    margin-bottom: 30px;
  }
  #title-screen .prompt {
    font-size: 13px;
    color: var(--text-faded);
    animation: blink 1.5s ease-in-out infinite;
  }
  @keyframes blink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.3; }
  }

  /* Fade overlay for transitions */
  #fade-overlay {
    position: fixed;
    inset: 0;
    background: var(--bg-void);
    opacity: 0;
    transition: opacity 0.5s ease;
    pointer-events: none;
    z-index: 500;
  }
  #fade-overlay.active { opacity: 1; }

  /* Cinematic narrative overlay */
  #cinematic-text {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    pointer-events: none;
    z-index: 50;
  }
  #cinematic-text .cine-inner {
    font-family: 'Crimson Text', serif;
    font-style: italic;
    font-size: 20px;
    color: var(--text-bright);
    text-align: center;
    max-width: 70%;
    line-height: 1.6;
    text-shadow: 0 0 20px rgba(0,0,0,0.9), 0 0 40px rgba(0,0,0,0.7);
    opacity: 0;
    transition: opacity 0.6s ease;
  }
  #cinematic-text .cine-inner.visible { opacity: 1; }
  #cinematic-text .cine-inner.fade-out { opacity: 0; transition: opacity 1.5s ease; }

  /* Character creation */
  #char-create-screen {
    max-width: 600px;
    width: 90%;
    text-align: center;
  }
  #char-create-screen h1 {
    font-family: 'Cinzel', serif;
    font-size: 22px;
    color: var(--accent);
    margin-bottom: 6px;
    letter-spacing: 3px;
  }
  #char-create-screen .step-label {
    font-family: 'Crimson Text', serif;
    font-style: italic;
    color: var(--text-dim);
    font-size: 15px;
    margin-bottom: 20px;
  }
  .create-options {
    display: flex;
    flex-direction: column;
    gap: 8px;
    margin: 16px 0;
  }
  .create-option {
    padding: 10px 16px;
    background: var(--bg-surface);
    border: 1px solid var(--border);
    border-radius: 4px;
    text-align: left;
    cursor: pointer;
    transition: border-color 0.2s, background 0.2s;
  }
  .create-option:hover, .create-option.selected {
    border-color: var(--accent);
    background: var(--bg-elevated);
  }
  .create-option .opt-name {
    color: var(--player);
    font-weight: bold;
    font-size: 13px;
  }
  .create-option .opt-desc {
    color: var(--text-dim);
    font-size: 11px;
    margin-top: 2px;
  }
  .create-option .opt-stats {
    color: var(--text-faded);
    font-size: 10px;
    margin-top: 3px;
  }
  .name-input {
    background: var(--bg-surface);
    border: 1px solid var(--border);
    color: var(--player);
    font-family: 'Cinzel', serif;
    font-size: 18px;
    padding: 8px 16px;
    text-align: center;
    outline: none;
    border-radius: 4px;
    width: 280px;
    letter-spacing: 2px;
  }
  .name-input:focus { border-color: var(--accent); }
  .stat-roll-display {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 8px;
    margin: 16px 0;
  }
  .stat-box {
    background: var(--bg-surface);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 8px;
    text-align: center;
  }
  .stat-box .stat-label { color: var(--text-dim); font-size: 10px; }
  .stat-box .stat-value { color: var(--text-bright); font-size: 20px; font-weight: bold; }
  .stat-box .stat-modifier { font-size: 11px; }
  .reroll-info { color: var(--text-faded); font-size: 11px; margin-top: 8px; }
  .create-nav { color: var(--text-faded); font-size: 11px; margin-top: 16px; }

  /* Death screen */
  #death-screen { text-align: center; }
  #death-screen .tombstone {
    font-family: 'Fira Code', monospace;
    font-size: 13px;
    color: var(--text-dim);
    line-height: 1.3;
    margin-bottom: 20px;
  }
  #death-screen .death-prompt {
    font-size: 12px;
    color: var(--text-faded);
    animation: blink 1.5s ease-in-out infinite;
  }

  /* Inventory overlay */
  #inventory-screen {
    max-width: 500px;
    width: 90%;
  }
  #inventory-screen h2 {
    font-family: 'Cinzel', serif;
    color: var(--accent);
    font-size: 16px;
    letter-spacing: 2px;
    margin-bottom: 12px;
  }
  .inv-list {
    max-height: 60vh;
    overflow-y: auto;
    font-size: 12px;
  }
  .inv-item {
    padding: 4px 8px;
    display: flex;
    justify-content: space-between;
    border-bottom: 1px solid var(--bg-surface);
  }
  .inv-item:hover { background: var(--bg-surface); }
  .inv-item .inv-key { color: var(--accent); margin-right: 8px; }
  .inv-item .inv-name { color: var(--item-common); }
  .inv-item .inv-name.equipped { color: var(--player); }
  .inv-item .inv-type { color: var(--text-faded); font-size: 10px; }
  .inv-category { color: var(--text-faded); font-size: 10px; text-transform: uppercase; letter-spacing: 2px; padding: 6px 8px 2px; border-bottom: 1px solid var(--border); margin-top: 4px; }
  .inv-category:first-child { margin-top: 0; }
  .inv-detail {
    margin-top: 10px;
    padding: 10px 12px;
    background: var(--bg-surface);
    border: 1px solid var(--border);
    border-radius: 3px;
    font-family: 'Fira Code', monospace;
    font-size: 11px;
    line-height: 1.7;
    min-height: 42px;
    color: var(--text-faded);
  }
  .inv-detail:empty { display: none; }
  .inv-detail .detail-name { color: var(--item-common); font-size: 12px; font-weight: bold; margin-bottom: 4px; }
  .inv-detail .detail-name.magic { color: var(--item-magic); }
  .inv-detail .detail-stat { color: var(--text-main); }
  .inv-detail .detail-label { color: var(--text-faded); }
  .inv-detail .detail-highlight { color: var(--accent); }
  .inv-detail .detail-compare { color: var(--xp); font-size: 10px; }
  .inv-footer { color: var(--text-faded); font-size: 11px; margin-top: 12px; }

  /* Lore journal overlay */
  #lore-screen {
    max-width: 520px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
  }
  #lore-screen .lore-header {
    font-family: 'Cinzel', serif;
    color: #d4a857;
    font-size: 14px;
    letter-spacing: 3px;
    margin-bottom: 8px;
  }
  #lore-screen .lore-title {
    font-family: 'Crimson Text', serif;
    font-style: italic;
    color: var(--text-bright);
    font-size: 18px;
    margin-bottom: 12px;
  }
  #lore-screen .lore-divider {
    border-top: 1px solid #d4a85733;
    margin-bottom: 16px;
  }
  #lore-screen .lore-text {
    font-family: 'Crimson Text', serif;
    color: var(--text-dim);
    font-size: 15px;
    line-height: 1.8;
    white-space: pre-wrap;
    min-height: 120px;
  }
  #lore-screen .lore-footer {
    color: var(--text-faded);
    font-size: 11px;
    margin-top: 20px;
    animation: blink 1.5s ease-in-out infinite;
  }

  /* Help overlay */
  #help-screen {
    max-width: 500px;
    width: 90%;
    font-size: 12px;
  }
  #help-screen h2 {
    font-family: 'Cinzel', serif;
    color: var(--accent);
    font-size: 16px;
    letter-spacing: 2px;
    margin-bottom: 12px;
  }
  .help-section { margin-bottom: 12px; }
  .help-section h3 { color: var(--text-dim); font-size: 11px; margin-bottom: 4px; }
  .help-row { display: flex; margin-bottom: 2px; }
  .help-row kbd { color: var(--accent); min-width: 80px; }
  .help-row span { color: var(--text-bright); }

  /* Level-up overlay */
  #levelup-screen { text-align: center; }
  #levelup-screen h2 {
    font-family: 'Cinzel', serif;
    color: var(--player);
    font-size: 20px;
    letter-spacing: 3px;
    margin-bottom: 6px;
  }
  #levelup-screen .lu-info {
    color: var(--text-dim);
    font-size: 12px;
    margin-bottom: 16px;
    font-family: 'Crimson Text', serif;
    font-style: italic;
  }

  /* ═══════ COMBAT OVERLAY ═══════ */
  #combat-screen {
    width: 680px;
    max-width: 95vw;
    background: var(--bg-deep);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 20px 24px;
    box-shadow: 0 0 40px rgba(240, 128, 48, 0.08), inset 0 0 60px rgba(0,0,0,0.4);
    animation: combatSlideIn 0.3s ease-out;
  }
  @keyframes combatSlideIn {
    from { opacity: 0; transform: translateY(-20px) scale(0.96); }
    to { opacity: 1; transform: translateY(0) scale(1); }
  }
  .combat-flavor {
    font-family: 'Crimson Text', serif;
    font-style: italic;
    color: var(--text-faded);
    font-size: 13px;
    text-align: center;
    min-height: 20px;
    margin-bottom: 16px;
    line-height: 1.5;
  }
  .combat-arena {
    display: flex;
    align-items: flex-start;
    justify-content: space-between;
    gap: 12px;
    margin-bottom: 16px;
  }
  .combat-player-side, .combat-monster-side {
    flex: 1;
    min-width: 0;
  }
  .combat-label {
    font-family: 'Fira Code', monospace;
    font-size: 13px;
    font-weight: bold;
    margin-bottom: 8px;
    letter-spacing: 0.5px;
  }
  .combat-player-side .combat-label { color: var(--player); }
  .combat-monster-side .combat-label.monster-name { color: var(--danger); text-align: center; }
  .combat-hp-row {
    display: flex;
    align-items: center;
    gap: 6px;
    margin-bottom: 6px;
    font-family: 'Fira Code', monospace;
    font-size: 11px;
  }
  .combat-hp-label { color: var(--text-faded); min-width: 20px; }
  .combat-hp-text { color: var(--text-main); min-width: 50px; font-size: 10px; }
  .combat-bar {
    flex: 1;
    height: 10px;
    background: rgba(255,255,255,0.06);
    border-radius: 2px;
    overflow: hidden;
    border: 1px solid var(--border);
  }
  .combat-bar-fill {
    height: 100%;
    border-radius: 1px;
    transition: width 0.4s ease;
  }
  .combat-bar-fill.player-bar { background: linear-gradient(90deg, #cc4444, #44cc44); }
  .combat-bar-fill.monster-bar { background: linear-gradient(90deg, #cc4444, #cc6644); }
  .combat-stat-row {
    font-family: 'Fira Code', monospace;
    font-size: 10px;
    color: var(--text-faded);
    display: flex;
    gap: 12px;
  }
  .combat-monster-art {
    font-family: 'Fira Code', monospace;
    font-size: 11px;
    line-height: 1.2;
    text-align: center;
    margin-bottom: 6px;
    min-height: 80px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--text-main);
  }
  .combat-center {
    flex: 0 0 160px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 120px;
  }
  .combat-dice-area {
    text-align: center;
    margin-bottom: 8px;
  }
  .combat-dice {
    font-family: 'Fira Code', monospace;
    font-size: 42px;
    font-weight: bold;
    color: var(--accent);
    min-width: 60px;
    text-align: center;
    line-height: 1;
    text-shadow: 0 0 12px rgba(240, 128, 48, 0.4);
  }
  .combat-dice.rolling {
    animation: diceFlicker 0.08s infinite;
  }
  @keyframes diceFlicker {
    0% { opacity: 1; }
    50% { opacity: 0.6; }
    100% { opacity: 1; }
  }
  .combat-dice.crit { color: var(--player); text-shadow: 0 0 20px rgba(240, 192, 64, 0.8); }
  .combat-dice.miss { color: var(--text-faded); text-shadow: none; }
  .combat-dice-label {
    font-family: 'Fira Code', monospace;
    font-size: 10px;
    color: var(--text-faded);
    margin-top: 2px;
  }
  .combat-roll-math {
    font-family: 'Fira Code', monospace;
    font-size: 11px;
    color: var(--text-faded);
    text-align: center;
    min-height: 16px;
    margin-bottom: 4px;
  }
  .combat-result {
    font-family: 'Fira Code', monospace;
    font-size: 14px;
    font-weight: bold;
    text-align: center;
    min-height: 20px;
    letter-spacing: 1px;
  }
  .combat-result.hit { color: var(--player); animation: resultFlash 0.4s ease; }
  .combat-result.miss-result { color: var(--text-faded); }
  .combat-result.crit-result { color: #ff4444; animation: resultFlash 0.4s ease; text-shadow: 0 0 16px rgba(255,68,68,0.6); }
  .combat-result.monster-hit { color: var(--danger); animation: resultFlash 0.4s ease; }
  .combat-result.slain { color: var(--player); font-size: 18px; animation: resultFlash 0.6s ease; text-shadow: 0 0 20px rgba(240,192,64,0.6); }
  @keyframes resultFlash {
    0% { transform: scale(1.4); opacity: 0.6; }
    100% { transform: scale(1); opacity: 1; }
  }
  .combat-log {
    font-family: 'Fira Code', monospace;
    font-size: 11px;
    color: var(--text-main);
    min-height: 24px;
    text-align: center;
    margin-bottom: 8px;
    line-height: 1.6;
  }
  .combat-log .combat-special { color: var(--xp); }
  .combat-prompt {
    font-family: 'Fira Code', monospace;
    font-size: 11px;
    color: var(--text-faded);
    text-align: center;
    animation: promptPulse 1.5s ease-in-out infinite;
  }
  @keyframes promptPulse {
    0%, 100% { opacity: 0.5; }
    50% { opacity: 1; }
  }
</style>
</head>
<body>

<!-- Fade overlay for transitions -->
<div id="fade-overlay"></div>

<!-- Title Screen -->
<div id="title-overlay" class="overlay">
  <div id="title-screen">
    <pre class="ascii-title">
 ██████╗  ███████╗ ███████╗ ██████╗
 ██╔══██╗ ██╔════╝ ██╔════╝ ██╔══██╗
 ██║  ██║ █████╗   █████╗   ██████╔╝
 ██║  ██║ ██╔══╝   ██╔══╝   ██╔═══╝
 ██████╔╝ ███████╗ ███████╗ ██║
 ╚═════╝  ╚══════╝ ╚══════╝ ╚═╝</pre>
    <div class="subtitle">~ A Descent into Darkness ~</div>
    <div class="prompt">Press ENTER to begin your journey</div>
  </div>
</div>

<!-- Character Creation -->
<div id="charcreate-overlay" class="overlay hidden">
  <div id="char-create-screen">
    <h1>FORGE YOUR FATE</h1>
    <div class="step-label" id="create-step-label">Step 1: Name your hero</div>
    <div id="create-content"></div>
    <div class="create-nav" id="create-nav"></div>
  </div>
</div>

<!-- Inventory -->
<div id="inventory-overlay" class="overlay hidden">
  <div id="inventory-screen">
    <h2>INVENTORY</h2>
    <div class="inv-list" id="inv-list"></div>
    <div class="inv-detail" id="inv-detail"></div>
    <div class="inv-footer" id="inv-footer"></div>
  </div>
</div>

<!-- Lore Journal -->
<div id="lore-overlay" class="overlay hidden">
  <div id="lore-screen">
    <div class="lore-header">JOURNAL</div>
    <div class="lore-title" id="lore-title"></div>
    <div class="lore-divider"></div>
    <div class="lore-text" id="lore-text"></div>
    <div class="lore-footer">Press ESC or ENTER to close &mdash; SPACE to skip</div>
  </div>
</div>

<!-- Help -->
<div id="help-overlay" class="overlay hidden">
  <div id="help-screen">
    <h2>COMMANDS</h2>
    <div id="help-content"></div>
  </div>
</div>

<!-- Level Up -->
<div id="levelup-overlay" class="overlay hidden">
  <div id="levelup-screen">
    <h2>LEVEL UP</h2>
    <div class="lu-info" id="lu-info"></div>
    <div id="lu-content"></div>
  </div>
</div>

<!-- Death Screen -->
<div id="death-overlay" class="overlay hidden">
  <div id="death-screen">
    <pre class="tombstone" id="tombstone-art"></pre>
    <div class="death-prompt">Press ENTER to return to the abyss</div>
  </div>
</div>

<!-- Combat Encounter -->
<div id="combat-overlay" class="overlay hidden">
  <div id="combat-screen">
    <div class="combat-flavor" id="combat-flavor"></div>
    <div class="combat-arena">
      <div class="combat-player-side">
        <div class="combat-label" id="combat-player-name"></div>
        <div class="combat-hp-row">
          <span class="combat-hp-label">HP</span>
          <div class="combat-bar"><div class="combat-bar-fill player-bar" id="combat-player-hp"></div></div>
          <span class="combat-hp-text" id="combat-player-hp-text"></span>
        </div>
        <div class="combat-stat-row">
          <span id="combat-player-ac"></span>
          <span id="combat-player-weapon"></span>
        </div>
      </div>
      <div class="combat-center">
        <div class="combat-dice-area">
          <div class="combat-dice" id="combat-dice">20</div>
          <div class="combat-dice-label">d20</div>
        </div>
        <div class="combat-roll-math" id="combat-roll-math"></div>
        <div class="combat-result" id="combat-result"></div>
      </div>
      <div class="combat-monster-side">
        <pre class="combat-monster-art" id="combat-monster-art"></pre>
        <div class="combat-label monster-name" id="combat-monster-name"></div>
        <div class="combat-hp-row">
          <span class="combat-hp-label">HP</span>
          <div class="combat-bar"><div class="combat-bar-fill monster-bar" id="combat-monster-hp"></div></div>
          <span class="combat-hp-text" id="combat-monster-hp-text"></span>
        </div>
        <div class="combat-stat-row">
          <span id="combat-monster-ac"></span>
        </div>
      </div>
    </div>
    <div class="combat-log" id="combat-log"></div>
    <div class="combat-prompt" id="combat-prompt">Press SPACE to attack</div>
  </div>
</div>

<!-- Main Game Layout -->
<div class="game-layout" id="game-layout" style="display:none;">
  <!-- Title Bar -->
  <div id="title-bar" class="panel">
    <span class="floor-name" id="floor-name">The Sunless Caverns — Floor 1</span>
    <span id="char-brief"></span>
    <span class="turn-count" id="turn-count">Turn 0</span>
  </div>

  <!-- Stats Panel -->
  <div id="stats-panel" class="panel">
    <div id="stats-content"></div>
  </div>

  <!-- Dungeon Map -->
  <div id="map-panel" class="panel" style="position:relative;">
    <div id="dungeon-map"></div>
    <div id="cinematic-text"><div class="cine-inner" id="cine-inner"></div></div>
  </div>

  <!-- Sidebar -->
  <div id="sidebar" class="panel">
    <div id="mini-map-container">
      <canvas id="mini-map" width="80" height="40"></canvas>
    </div>
    <div class="action-hints" id="action-hints">
      <h3>ACTIONS</h3>
      <div id="hints-content"></div>
    </div>
  </div>

  <!-- Message Log -->
  <div id="log-panel" class="panel">
    <div id="message-log"></div>
  </div>
</div>

<script>
(function() {
'use strict';

// ════════════════════════════════════════════════════
// SECTION 1: CONSTANTS & CONFIGURATION
// ════════════════════════════════════════════════════

const MAP_W = 80, MAP_H = 40;
const VIEW_W = 60, VIEW_H = 24;
const MAX_INVENTORY = 20;
const MAX_FLOORS = 10;

const TILE = { VOID: 0, WALL: 1, FLOOR: 2, DOOR: 3, STAIRS_DOWN: 4, STAIRS_UP: 5, TRAP: 6, WATER: 7 };

const TILE_CH = {
  [TILE.VOID]: ' ', [TILE.WALL]: '#', [TILE.FLOOR]: '\u00B7',
  [TILE.DOOR]: '+', [TILE.STAIRS_DOWN]: '>', [TILE.STAIRS_UP]: '<',
  [TILE.TRAP]: '^', [TILE.WATER]: '~'
};

const TILE_CLASS = {
  [TILE.VOID]: 't-void', [TILE.WALL]: 't-wall', [TILE.FLOOR]: 't-floor',
  [TILE.DOOR]: 't-door', [TILE.STAIRS_DOWN]: 't-stairs', [TILE.STAIRS_UP]: 't-stairs',
  [TILE.TRAP]: 't-trap', [TILE.WATER]: 't-water'
};

const FLOOR_NAMES = [
  '', 'The Sunless Caverns', 'The Fungal Depths', 'The Whispering Halls',
  'The Bone Warrens', 'The Flooded Crypt', 'The Iron Mines',
  'The Abyssal Rift', 'The Burning Chasm', 'The Obsidian Vault',
  "The Dragon's Sanctum"
];

const FLOOR_DESCRIPTIONS = [
  [],
  // Floor 1 — The Entrance
  ['The entrance to the dungeon yawns before you. Torchlight barely penetrates the gloom.',
   'Cold stone steps lead down into darkness. Water drips somewhere ahead.',
   'A stale breeze carries the scent of earth and forgotten places.',
   'Rough-hewn stairs descend into the dark. The world above already feels distant.',
   'The last light of the surface fades behind you. There is only forward now.',
   'Bootprints in the dust — others have come this way. None returned.'],
  // Floor 2 — Upper Caverns
  ['The walls here are slick with moisture. Something scurries in the shadows.',
   'Fungal growths emit a faint bioluminescence along the corridor walls.',
   'The passage narrows. Your shoulders brush cold stone on both sides.',
   'A distant echo — was that a voice, or just the wind through cracks?',
   'The air is heavier here, thick with the smell of damp and decay.',
   'Roots from the world above pierce the ceiling like grasping fingers.'],
  // Floor 3 — The Whispering Dark
  ['A low moan echoes through the stone corridors. The air tastes of copper.',
   'Whispers seem to emanate from the very walls themselves.',
   'The darkness presses in like a living thing. Your torch feels smaller.',
   'Old blood stains the floor in a trail leading deeper.',
   'The silence between your footsteps is absolute and terrible.',
   'A draft carries the faintest hint of something sweet and rotting.'],
  // Floor 4 — The Catacombs
  ['Bones crunch underfoot. This place reeks of death.',
   'Skeletal remains line the walls in grotesque arrangements.',
   'Row upon row of burial niches stretch into the darkness. Most are empty.',
   'The dead were stacked here without ceremony. This is a place of forgetting.',
   'Funerary inscriptions cover every surface, names worn to nothing by time.',
   'A cold that has nothing to do with temperature settles into your bones.'],
  // Floor 5 — The Drowned Halls
  ['Water pools on the floor, black and still. Something moves beneath.',
   'The ceiling drips ceaselessly. Your torchlight reflects off dark water.',
   'Water runs down the walls in sheets. The floor is treacherous and slick.',
   'An underground river roars somewhere behind the walls.',
   'The waterline on the stone is well above your head. This place floods.',
   'Pale eyeless fish dart away from your torchlight in the shallows.'],
  // Floor 6 — The Iron Warrens
  ['Rusted iron chains hang from the walls. The ring of distant hammers echoes.',
   'Abandoned mine carts sit on corroded rails. The air is thick with dust.',
   'Someone built a civilization here once. Now only rust and silence remain.',
   'Iron doors hang off their hinges. Whatever was locked in is long gone.',
   'The floor is riveted iron plate. Your every step rings out like a bell.',
   'Machine parts litter the ground — gears, pistons, things with no name.'],
  // Floor 7 — The Abyss Edge
  ['The ground drops away into impossible darkness. A hot wind rises from below.',
   'Cracks in the earth glow with a sullen red light.',
   'The world feels thin here, as if reality itself is wearing through.',
   'A tremor runs through the stone. The deep places are restless.',
   'You stand at the edge of the world above. Below is something older.',
   'The air shimmers with heat. Your throat burns with every breath.'],
  // Floor 8 — The Furnace
  ['Heat shimmers the air. The stone walls are warm to the touch.',
   'Rivers of molten rock carve channels through the chamber floors.',
   'The heat is a physical force pressing against you from all sides.',
   'Volcanic vents hiss and spit. The air reeks of sulfur.',
   'The stone beneath your feet pulses with a deep, slow rhythm.',
   'Shadows dance in the firelight. Not all of them are yours.'],
  // Floor 9 — The Obsidian Depths
  ['Black glass walls reflect your torchlight in strange patterns.',
   'The obsidian surfaces seem to absorb sound itself.',
   'Your distorted reflection stares back from every surface, always a moment behind.',
   'The glass walls show things that are not in this room.',
   'Silence so complete you can hear your own heartbeat echo.',
   'Obsidian shards crunch underfoot like black snow.'],
  // Floor 10 — The Dragon's Sanctum
  ['The stench of sulfur is overwhelming. Treasure gleams in impossible heaps.',
   'Scorched stone and the rumble of something ancient stirring.',
   'The walls are scarred by claws wider than you are tall.',
   'A low vibration fills the air — breathing. Something enormous breathes here.',
   'Bitcoin tokens litter the floor like scales shed from a golden beast.',
   'The heat is unbearable. The air itself seems to ignite.']
];

// ════════════════════════════════════════════════════
// SECTION 2: DATA TABLES
// ════════════════════════════════════════════════════

const RACES = {
  human:    { name: 'Human',    mods: { str:1, dex:1, con:1, int:1, wis:1 }, passive: 'Versatile: +10% XP gain', desc: 'Adaptable and ambitious, humans excel in all pursuits.' },
  dwarf:    { name: 'Dwarf',    mods: { str:2, dex:0, con:2, int:0, wis:1 }, passive: 'Darkvision: Extended sight radius', desc: 'Stout and resilient, born of stone and fire.' },
  elf:      { name: 'Elf',      mods: { str:0, dex:2, con:-1, int:2, wis:1 }, passive: 'Magic Resist: +2 on spell saves', desc: 'Graceful and ancient, attuned to the arcane.' },
  halfling: { name: 'Halfling', mods: { str:-1, dex:3, con:1, int:0, wis:1 }, passive: 'Lucky: Reroll natural 1 once per floor', desc: 'Small but remarkably fortunate.' }
};

const CLASSES = {
  warrior: { name: 'Warrior', hitDie: 10, primary: 'str', desc: 'Masters of martial combat.', ability: 'Cleave: Killing blow grants free attack on adjacent foe', startWeapon: 'Longsword', startArmor: 'Chain Mail' },
  rogue:   { name: 'Rogue',   hitDie: 6,  primary: 'dex', desc: 'Shadows and steel.',         ability: 'Backstab: +2d6 damage on unaware targets',       startWeapon: 'Dagger',    startArmor: 'Leather Armor' },
  mage:    { name: 'Mage',    hitDie: 4,  primary: 'int', desc: 'Wielders of arcane might.',   ability: 'Spellcasting: Fireball, Frost Ray, Magic Missile', startWeapon: 'Staff',     startArmor: 'Robes' },
  cleric:  { name: 'Cleric',  hitDie: 8,  primary: 'wis', desc: 'Divine servants of light.',   ability: 'Heal (3/floor) and Turn Undead',                  startWeapon: 'Mace',      startArmor: 'Scale Mail' }
};

const BESTIARY = {
  rat:      { ch:'r', color:'#886644', name:'Giant Rat',     hp:3,  ac:10, atk:1,  dmg:[1,2,0],  xp:10,  behavior:'wander', tier:1 },
  bat:      { ch:'b', color:'#666688', name:'Cave Bat',      hp:2,  ac:12, atk:0,  dmg:[1,2,0],  xp:8,   behavior:'wander', tier:1 },
  goblin:   { ch:'g', color:'#44aa44', name:'Goblin',        hp:7,  ac:12, atk:3,  dmg:[1,4,0],  xp:25,  behavior:'aggressive', tier:1 },
  kobold:   { ch:'k', color:'#aa6644', name:'Kobold',        hp:5,  ac:11, atk:2,  dmg:[1,4,0],  xp:15,  behavior:'aggressive', tier:1 },
  orc:      { ch:'o', color:'#668844', name:'Orc',           hp:16, ac:14, atk:6,  dmg:[1,8,2],  xp:50,  behavior:'aggressive', tier:2 },
  skeleton: { ch:'s', color:'#cccccc', name:'Skeleton',      hp:12, ac:13, atk:5,  dmg:[1,6,1],  xp:40,  behavior:'aggressive', tier:2, undead:true },
  spider:   { ch:'S', color:'#444444', name:'Giant Spider',  hp:14, ac:12, atk:5,  dmg:[1,6,0],  xp:45,  behavior:'wander', tier:2, special:'poison' },
  ogre:     { ch:'O', color:'#888844', name:'Ogre',          hp:26, ac:11, atk:7,  dmg:[2,6,2],  xp:80,  behavior:'aggressive', tier:2 },
  troll:    { ch:'T', color:'#228822', name:'Troll',         hp:30, ac:15, atk:8,  dmg:[2,6,3],  xp:120, behavior:'aggressive', tier:3, special:'regen' },
  wraith:   { ch:'W', color:'#8844cc', name:'Wraith',        hp:22, ac:16, atk:7,  dmg:[1,8,2],  xp:100, behavior:'aggressive', tier:3, special:'drain', undead:true },
  vampire:  { ch:'V', color:'#cc2222', name:'Vampire',       hp:35, ac:17, atk:9,  dmg:[2,6,3],  xp:150, behavior:'aggressive', tier:3, special:'drain', undead:true },
  golem:    { ch:'G', color:'#888888', name:'Iron Golem',    hp:50, ac:18, atk:10, dmg:[2,8,4],  xp:200, behavior:'stationary', tier:3 },
  dragon:   { ch:'D', color:'#ff4444', name:'Ancient Dragon', hp:80, ac:20, atk:12, dmg:[3,8,6], xp:500, behavior:'stationary', tier:4, special:'breath' }
};

const MONSTER_ART = {
  rat: `
      /\\._./\\
     ( o   o )
      >  ^  <
     /|     |\\
    (_|     |_)`,
  bat: `
       /\\  /\\
      /  \\/  \\
     / /\\  /\\ \\
     \\/  \\/  \\/
       \\    /
        \\  /
         \\/`,
  goblin: `
       ,---.
      /  o o\\
      | \\_^_/|
      /|  =  |\\
     / | HHH | \\
       |_| |_|
       d_| |_b`,
  kobold: `
      _/\\_
     / o o\\
     \\ == /
    --|++++|--
      | || |
      |_||_|
      /_/\\_\\`,
  orc: `
      ___
     /o  o\\
    ( \\vv/ )
     |\\  /|
    /| \\/ |\\
    ||_/\\_||
     |_||_|`,
  skeleton: `
      .-.
     (o.o)
      |=|
     d|=|b
      |=|
     /|=|\\
    (_/ \\_)`,
  spider: `
     /\\ () /\\
    /  \\;;/  \\
   / /\\ \\/ /\\ \\
   \\ \\/    \\/ /
    \\  (oo)  /
     \\'--''/
      '-..-'`,
  ogre: `
      ,---.
     /O   O\\
    | \\___/ |
    |  ===  |
   /|       |\\
  / |=======| \\
    |_|   |_|`,
  troll: `
     _,,,_
    /o   O\\
   ( \\_W_/ )
    |  |  |
   /| /_\\ |\\
   ||/   \\||
   |_|   |_|`,
  wraith: `
    .  _  .
   / \\/ \\/ \\
  ( (o  o) )
   \\ \\~~/ /
    \\|  |/
    /|  |\\
  ~~ ~~~~ ~~`,
  vampire: `
   \\\\    //
    \\\\  //
     (oo)
    /|  |\\
   ( |\\/| )
    \\|  |/
     |--|
    _/  \\_`,
  golem: `
    [====]
    |o  o|
    | -- |
   /|====|\\
  [=|    |=]
   ||    ||
   |_|  |_|`,
  dragon: `
        /\\_/\\
    ===/ o o \\===
   /    \\___/    \\
  /   ___|||___   \\
  \\__/  ||||  \\__/
       / || \\
      /  ||  \\
   ~~~~~~~~~~~~~~`
};

const MONSTER_FLAVOR = {
  rat: [
    'A massive rat hisses from the shadows, its eyes gleaming with feral hunger.',
    'Something skitters in the dark — a rat the size of a dog blocks your path.',
    'The stench hits you first. A giant rat crouches ahead, baring yellowed fangs.'
  ],
  bat: [
    'A shriek echoes from above. Leathery wings unfurl in the darkness.',
    'The flutter of wings — a cave bat dives toward you from the ceiling.',
    'You disturb a roosting bat. It drops from the shadows with a screech.'
  ],
  goblin: [
    'A goblin emerges from the shadows, its crude blade scraping against stone.',
    'Beady eyes glint in the dark. A goblin snarls and raises its weapon.',
    'A high-pitched cackle echoes ahead. A goblin steps into view, grinning wickedly.'
  ],
  kobold: [
    'A small reptilian figure darts from behind a pillar, hissing threats.',
    'A kobold shrieks a war cry far too loud for its tiny frame.',
    'Scales glitter in the torchlight. A kobold brandishes a jagged blade.'
  ],
  orc: [
    'A hulking orc steps from the shadows, tusks bared in a savage grin.',
    'The ground trembles with heavy footfalls. An orc blocks your path, axe raised.',
    'A guttural roar fills the corridor. An orc charges from the darkness.'
  ],
  skeleton: [
    'Bones clatter as a skeletal figure rises from the ground, empty sockets blazing.',
    'A skeleton lurches forward, its jaw hanging open in a silent scream.',
    'The dead do not rest here. A skeleton turns toward you, sword scraping stone.'
  ],
  spider: [
    'Webs cling to your face. A massive spider descends from above on a silk thread.',
    'Eight eyes reflect your torchlight. A giant spider skitters toward you.',
    'The clicking of mandibles. A spider the size of a horse emerges from its web.'
  ],
  ogre: [
    'The ceiling shakes. A massive ogre ducks through a doorway, club in hand.',
    'A stench like rotting meat precedes the ogre. It spots you and grins.',
    'An ogre bellows, the sound reverberating through the stone chamber.'
  ],
  troll: [
    'The air thickens with the reek of swamp and decay. A troll looms before you.',
    'Green flesh knits itself together before your eyes. The troll is already regenerating.',
    'A troll blocks the passage, its long arms nearly touching the walls on both sides.'
  ],
  wraith: [
    'The temperature plummets. A spectral figure glides through the wall toward you.',
    'A chill runs down your spine. The wraith materializes from the darkness itself.',
    'Your torch gutters and dims. A wraith drifts forward, reaching with ghostly claws.'
  ],
  vampire: [
    'A pale figure steps from the shadows, eyes burning with ancient hunger.',
    'The darkness coalesces into a regal form. The vampire smiles, revealing fangs.',
    'A cold voice whispers your name. The vampire has been expecting you.'
  ],
  golem: [
    'Iron plates grind together as the golem activates, eyes flaring with arcane light.',
    'A construct of iron and dark magic stands guard. It turns to face you with a metallic groan.',
    'The iron golem was motionless — a statue. Now it moves, each step shaking the floor.'
  ],
  dragon: [
    'The cavern opens into a vast chamber. Atop a mountain of Bitcoin, the dragon stirs.',
    'Heat washes over you like a furnace door opening. The ancient dragon raises its head.',
    'Smoke curls from nostrils like chimneys. The dragon fixes you with an eye older than empires.'
  ]
};

const ROOM_DESCRIPTIONS = [
  // Tier 0: Floors 1-3 — Caverns
  [
    'The chamber opens up. Stalactites hang like stone teeth from the ceiling.',
    'Water pools in the corners of this room, still and dark.',
    'Rat droppings litter the floor. Something was nesting here recently.',
    'Crude scratches mark the walls — tally marks, perhaps, from some prior prisoner.',
    'A draft of cold air brushes past you. There must be another passage nearby.',
    'Moss clings to the damp walls. Mushrooms cluster in the corners.',
    'The stone here is worn smooth by the passage of countless feet — or claws.',
    'A collapsed section of wall reveals rough-hewn rock beyond.',
    'Empty iron sconces line the walls. Someone once lit these halls.',
    'The ceiling is low here. You crouch instinctively.',
    'A foul smell wafts from a crack in the floor.',
    'Old bones lie scattered — animal, you hope.',
    'Torchlight catches something glinting in a wall crevice.',
    'The echo of your footsteps sounds wrong here, as if the room is larger than it appears.',
    'Cobwebs hang in thick curtains across the doorway.',
    'A pool of stagnant water reflects your face, pale and drawn.',
    'Scratching sounds come from inside the walls. Then silence.',
    'The air is still and stale. Nothing has breathed here in a long time.',
    'Broken pottery and shattered glass crunch beneath your boots.',
    'A wooden door lies splintered on the ground, torn from its hinges.',
    'Pale cave crickets scatter from your torchlight in a wave.',
    'Faint daylight filters through a crack far above. So close, yet unreachable.',
    'A rusted grate covers a shaft descending into deeper darkness.',
    'The walls are scarred with claw marks at varying heights.',
    'Someone carved "TURN BACK" into the stone in shaking letters.',
    'A skeleton sits propped against the wall, a dagger still clutched in its hand.',
    'The room smells of wet earth and rotting wood.',
    'Your torch sputters. The darkness leans in, eager.',
    'Chisel marks cover the ceiling — an unfinished expansion, abandoned.',
    'A trickle of water follows a groove worn into the floor over centuries.'
  ],
  // Tier 1: Floors 4-6 — Crypts and warrens
  [
    'Stone coffins line the walls, their lids askew.',
    'The walls are carved with names and dates — a catacomb of the forgotten.',
    'Candles flicker in alcoves though no one tends them.',
    'A cold wind moans through this chamber like a dying breath.',
    'Bones are arranged in decorative patterns along the walls — someone took care with these dead.',
    'An altar stands in the center, stained dark with ancient offerings.',
    'The floor is flooded ankle-deep. Something ripples in the dark water.',
    'Iron cages hang from the ceiling, some still occupied by skeletal remains.',
    'Funerary urns sit on stone shelves, many shattered and empty.',
    'The air tastes of embalming spices and dust.',
    'Grave goods lie scattered — someone has been looting these tombs.',
    'A statue of a weeping figure guards this room, its face worn smooth.',
    'Chains dangle from the walls. This was a prison once.',
    'The walls seep moisture that smells faintly of copper.',
    'Faded murals depict scenes of judgment and descent.',
    'A sarcophagus lies open and empty. The occupant left on its own.',
    'Prayer beads are scattered across the floor like discarded teeth.',
    'The ceiling is painted with stars — a sky for the dead to gaze upon.',
    'Hooded statues stand in silent vigil along the walls.',
    'A well descends into absolute blackness. You drop a stone. No sound returns.',
    'Scratches on the inside of a coffin lid. Someone woke up down here.',
    'The air is thick with incense that has no source.',
    'Grave dirt is piled at the entrance. Something was digging its way out.',
    'A bell rope hangs from the ceiling, attached to nothing above.',
    'The dead here were buried with their weapons drawn.',
    'An embalming table sits in the center, its leather straps cracked with age.',
    'Candle wax has pooled across the floor in strange, deliberate patterns.',
    'A mirror mounted on the wall reflects a room that is not this one.',
    'The sound of weeping echoes from somewhere you cannot find.',
    'Iron-bound books sit chained to stone lecterns, their pages turned to dust.'
  ],
  // Tier 2: Floors 7-9 — Deep/volcanic
  [
    'The rock here is warm to the touch. Fissures glow with dim red light.',
    'Crystals jut from the walls, refracting your torchlight into fractured rainbows.',
    'The air shimmers with heat. Sweat beads on your brow instantly.',
    'A chasm splits the chamber floor. You can hear something far below.',
    'Strange symbols are burned into the stone — not carved, burned.',
    'Obsidian pillars rise from floor to ceiling, smooth as glass.',
    'The walls pulse with a faint heartbeat rhythm. Or perhaps that is your own.',
    'Molten rock drips from a crack above, pooling in a glowing puddle.',
    'Ancient dwarven machinery sits rusted and silent along one wall.',
    'The stone here is black and glassy. Your reflection stares back, distorted.',
    'Sulfurous fumes vent from cracks in the floor.',
    'A forge sits cold and dark, but the metal on its anvil still glows faintly.',
    'The ceiling is impossibly high here, lost in darkness above.',
    'Something massive gouged claw marks into the stone floor.',
    'The air crackles with residual magic. Your hair stands on end.',
    'A river of magma flows beneath a stone bridge barely wide enough for one.',
    'Crystallized bones jut from the volcanic rock — fossils from an older age.',
    'The floor is etched with a vast arcane circle, still faintly glowing.',
    'A pillar of basalt has been carved into a screaming face.',
    'Veins of gold run through the stone like arteries through flesh.',
    'The heat makes your armor almost too hot to wear.',
    'Something vast shifts beneath the floor. Dust rains from above.',
    'A dwarven throne sits before a collapsed tunnel, its occupant long gone.',
    'Runes pulse in the walls, dimming as you approach, brightening as you leave.',
    'Stalactites of black glass hang like frozen daggers overhead.',
    'An underground lake of molten rock bathes the chamber in hellish light.',
    'The remains of a camp — bedrolls, cold cookfire. Whoever was here left in a hurry.',
    'Ancient chains thick as your arm are bolted into the floor. What were they holding?',
    'The temperature drops suddenly. Frost forms on volcanic glass — wrong, all wrong.',
    'A perfectly circular hole in the floor descends straight down. Something breathes below.'
  ],
  // Tier 3: Floor 10 — Dragon's domain
  [
    'Bitcoin tokens crunch underfoot. This is the dragon\'s outer wallet.',
    'Scorched skeletons of adventurers line the walls — a warning.',
    'The heat is nearly unbearable. The very air seems to burn.',
    'Treasure beyond imagining glitters in the firelight.',
    'The walls bear the marks of dragon fire — stone melted and reformed.',
    'Claw marks as wide as doorways score the stone floor.',
    'A half-melted suit of plate armor lies crumpled against the wall.',
    'The ceiling is blackened with centuries of dragon fire.',
    'Coins and gems are fused into the stone floor by ancient heat.',
    'The bones of heroes are arranged around the chamber like trophies.',
    'A low rumble shakes loose dust. The beast knows you are here.',
    'The air tastes of ash and endings. This is where adventurers come to die.',
    'A broken sword of legendary make lies shattered among the Bitcoin.',
    'Scales the size of shields are embedded in the walls.',
    'The stench of sulfur and wealth mingles into something almost sweet.'
  ]
];

const WEAPONS = [
  { name:'Dagger',     dmg:[1,4,0],  stat:'dex', weight:1,  value:5,   ch:'/' },
  { name:'Mace',       dmg:[1,6,0],  stat:'str', weight:3,  value:15,  ch:'/' },
  { name:'Longsword',  dmg:[1,8,0],  stat:'str', weight:3,  value:30,  ch:'/' },
  { name:'Staff',      dmg:[1,6,0],  stat:'int', weight:2,  value:15,  ch:'/' },
  { name:'Greataxe',   dmg:[1,12,0], stat:'str', weight:5,  value:50,  ch:'/' },
  { name:'Warhammer',  dmg:[1,10,0], stat:'str', weight:4,  value:40,  ch:'/' }
];

const ARMORS = [
  { name:'Robes',         acBonus:0, dexCap:99, weight:1,  value:5,   ch:'[' },
  { name:'Leather Armor', acBonus:1, dexCap:99, weight:3,  value:20,  ch:'[' },
  { name:'Scale Mail',    acBonus:3, dexCap:2,  weight:6,  value:50,  ch:'[' },
  { name:'Chain Mail',    acBonus:4, dexCap:2,  weight:8,  value:75,  ch:'[' },
  { name:'Plate Armor',   acBonus:6, dexCap:0,  weight:12, value:200, ch:'[' }
];

const POTIONS = [
  { name:'Healing Potion',      effect:'heal',     amount:[2,6,2], ch:'!', color:'#cc4444', value:10 },
  { name:'Greater Healing',     effect:'heal',     amount:[4,4,6], ch:'!', color:'#ff4444', value:30 },
  { name:'Potion of Strength',  effect:'buff_str', duration:20,    ch:'!', color:'#cc8844', value:20 },
  { name:'Potion of Speed',     effect:'buff_dex', duration:20,    ch:'!', color:'#44cc44', value:20 }
];

const SCROLLS = [
  { name:'Scroll of Fireball',  effect:'fireball',   damage:[3,6,0], ch:'?', color:'#ff8844', value:25 },
  { name:'Scroll of Teleport',  effect:'teleport',   ch:'?', color:'#8844ff', value:15 },
  { name:'Scroll of Mapping',   effect:'reveal_map', ch:'?', color:'#4488ff', value:12 }
];

const LORE_SCROLLS = [
  {
    floor: 1, name: 'Torn Journal Page', title: 'Entry I: The Descent',
    text: "Day 1. I write this by torchlight at the mouth of the deep. The Guild sent me to map these caverns after the miners broke through into something older. The air here tastes wrong \u2014 metallic, alive. I can hear water below, and something else. A rhythm, like breathing. I tell myself it is the wind.\n\nI have marked my path with chalk. I will not become another name scratched into the stone.",
    ch: '\u00B6', color: '#d4a857', value: 0
  },
  {
    floor: 2, name: 'Water-Stained Journal', title: 'Entry II: The Fungal Dark',
    text: "Day 4. The fungi here glow with their own light \u2014 beautiful and terrible. I found boot prints in the dust that are not mine. Someone else came this way and did not return. The chalk marks I left yesterday have been... rearranged. Not erased. Moved. As if something wanted me to go a different way.\n\nI followed my compass instead. I am not a fool.",
    ch: '\u00B6', color: '#d4a857', value: 0
  },
  {
    floor: 3, name: 'Crumpled Parchment', title: 'Entry III: Whispers',
    text: "Day 7. The walls whisper. Not words exactly, but almost-words, as if a voice were speaking just below the threshold of understanding. I caught myself leaning in to listen. When I pulled away, an hour had passed.\n\nI found a skeleton clutching a journal much like this one. The last entry read only: 'It knows my name.' I did not read the name. I will not read the name.",
    ch: '\u00B6', color: '#d4a857', value: 0
  },
  {
    floor: 4, name: 'Bloodstained Journal', title: 'Entry IV: The Dead Below',
    text: "Day 12. The catacombs stretch in every direction. These are not natural caves \u2014 someone BUILT this. Thousands of burial niches, stacked floor to ceiling, each one sealed with a name plaque. Most of the names are in no language I recognize.\n\nSome of the niches are empty from the inside. The seals broken outward.\n\nMy torch burns blue here. That means something. I cannot remember what.",
    ch: '\u00B6', color: '#d4a857', value: 0
  },
  {
    floor: 5, name: 'Damp Journal Fragment', title: 'Entry V: Rising Water',
    text: "Day 16. The water is rising. Not slowly \u2014 in surges, as if something far below is breathing and the water rises with each exhale. I found an air pocket and made camp on a stone shelf.\n\nIn the still water I saw my reflection. It was not doing what I was doing. It was writing in its own journal, and when it looked up at me, it smiled.\n\nI do not look at the water anymore.",
    ch: '\u00B6', color: '#d4a857', value: 0
  },
  {
    floor: 6, name: 'Scorched Journal', title: 'Entry VI: The Builders',
    text: "Day 20. I found the machines. Vast iron works, gears the size of houses, all silent now. Dwarven, I think, but older than any dwarven craft I have studied. These halls were not mined \u2014 they were MANUFACTURED.\n\nThere are instruction plates bolted to the walls in a script I almost recognize. One word keeps repeating. I have been sounding it out for hours. I think it means 'containment.'\n\nContainment of what?",
    ch: '\u00B6', color: '#d4a857', value: 0
  },
  {
    floor: 7, name: 'Heat-Warped Journal', title: 'Entry VII: The Edge',
    text: "Day 25. I have reached the boundary between the built world and something else. Below the iron floors, the earth glows. The temperature is barely survivable. My water skins burst from the heat.\n\nI found another explorer's camp \u2014 recent, perhaps days old. Their journal ended mid-sentence. The last word was 'BEHIND'\n\nI have started walking with my back to walls.",
    ch: '\u00B6', color: '#d4a857', value: 0
  },
  {
    floor: 8, name: 'Charred Parchment', title: 'Entry VIII: The Furnace Heart',
    text: "Day 30. The containment is failing. I understand now what the dwarves built here \u2014 not a mine, not a fortress. A CAGE. The entire mountain is a cage, and the machine was the lock.\n\nThe machine is broken. Someone broke it deliberately. I found tool marks, precise and purposeful. Someone WANTED what is below to wake up.\n\nThe ground trembles constantly now. The thing beneath is stirring.",
    ch: '\u00B6', color: '#d4a857', value: 0
  },
  {
    floor: 9, name: 'Obsidian-Etched Note', title: 'Entry IX: The Truth',
    text: "Day 33. I can see it through the obsidian walls. Not clearly \u2014 shapes, movement, an eye larger than I am. It has been watching me since I entered. Every room, every corridor, every moment of false safety \u2014 observed.\n\nThe whispers were never the walls. They were its voice, too vast for human ears to parse into words. I understand them now. It is saying the same thing, over and over:\n\n'Deeper. Come deeper.'",
    ch: '\u00B6', color: '#d4a857', value: 0
  },
  {
    floor: 10, name: 'Final Journal Entry', title: 'Entry X: The Bottom',
    text: "I do not know what day it is. There is no more pretending. The dragon is not the treasure guardian the stories describe. It is the LAST LOCK. The final piece of the containment. It guards nothing above \u2014 it guards against what lies BELOW.\n\nIf you are reading this, you are already too deep. The mountain wants you here. It has always wanted you here.\n\nDo not kill the dragon.\n\nGods forgive me. I think I am going to kill the dragon.\n\n\u2014 Elara Voss, Cartographer, Guild of the Iron Compass",
    ch: '\u00B6', color: '#d4a857', value: 0
  }
];

const ENVIRONMENTAL_EVENTS = [
  // Tier 0: Floors 1-3 — Caverns
  [
    { text: 'A cold breath of air extinguishes your torch for a heartbeat. When it relights, the shadows have moved.', log: 'A gust of cold air makes your torch flicker.', effect: null },
    { text: 'You hear footsteps behind you. When you turn, there is nothing. When you turn back, you are certain something has changed.', log: 'Footsteps echo behind you, then vanish.', effect: null },
    { text: 'A rat the size of a cat watches you from a ledge, then slowly shakes its head before vanishing into a crack.', log: 'An unnervingly large rat stares at you, then disappears.', effect: null },
    { text: 'Water drips from the ceiling onto your neck. It is warm.', log: 'Warm water drips on you from above.', effect: null },
    { text: 'Scratch marks appear on the wall beside you. They were not there a moment ago.', log: 'Fresh scratch marks appear on the wall.', effect: null },
    { text: 'You find a single copper coin on the ground, warm to the touch, as if someone just dropped it.', log: 'You find a warm coin on the ground.', effect: 'coin1' },
    { text: 'A distant sound \u2014 metal on stone, rhythmic, purposeful. Mining? Digging? It stops the moment you notice it.', log: 'A distant metallic rhythm stops abruptly.', effect: null },
    { text: 'The air pressure shifts. Your ears pop. Somewhere deep below, something just moved.', log: 'Your ears pop as the air pressure shifts.', effect: null },
    { text: 'A chalk arrow on the wall points deeper into the dungeon. The chalk is fresh.', log: 'A fresh chalk arrow points deeper.', effect: null },
    { text: 'For a moment, your shadow on the wall has a different shape. Taller. Thinner. Then it is normal again.', log: 'Your shadow flickers into a different shape.', effect: null }
  ],
  // Tier 1: Floors 4-6 — Crypts
  [
    { text: 'A ghostly figure stands at the end of the corridor. It raises one hand, as if in warning, then dissolves into mist.', log: 'A ghostly figure appears, warns you, and vanishes.', effect: null },
    { text: 'Every candle in the room ignites at once, burns blue for three seconds, then dies.', log: 'Candles ignite blue, then extinguish.', effect: null },
    { text: "You hear singing. A woman's voice, beautiful and sad, echoing from everywhere and nowhere.", log: "A woman's singing echoes through the crypt.", effect: null },
    { text: "A coffin lid slides open an inch. A whisper escapes: 'Not yet.' The lid slides shut.", log: "A whisper from a coffin: 'Not yet.'", effect: null },
    { text: 'Cold hands brush your shoulder from behind. There is nobody there. The cold lingers.', log: 'Invisible cold hands touch your shoulder.', effect: 'chill' },
    { text: 'Names begin appearing on the wall, written in frost. Your name is among them.', log: 'Frost-written names appear on the wall. Yours is among them.', effect: null },
    { text: "A prayer book on a lectern flips to a specific page as you pass. The text reads: 'For those who descend and do not return.'", log: 'A prayer book opens to a page about those who descend.', effect: null },
    { text: "You step on something that crunches. Not bone \u2014 a small wooden toy. A child's plaything, here in the crypt.", log: "You step on a child's toy in the crypt.", effect: null },
    { text: 'The temperature drops so suddenly your breath becomes visible. Frost forms on your armor. Then it passes.', log: 'Temperature plummets; frost forms on your armor.', effect: 'chill' },
    { text: 'A bell tolls once, deep and resonant. There is no bell in this room. There is no bell on this floor.', log: 'A phantom bell tolls once.', effect: null }
  ],
  // Tier 2: Floors 7-9 — Deep/volcanic
  [
    { text: 'The floor beneath you pulses like a heartbeat. Once. Twice. Then stops.', log: 'The floor pulses like a heartbeat.', effect: null },
    { text: 'You blink and you are facing the opposite direction. Your footprints lead away from where you thought you came.', log: 'You suddenly face the wrong direction.', effect: null },
    { text: "A voice from the stone speaks one word in a language you do not know. You understand it anyway. It means 'deeper.'", log: "A voice from the stone says a word meaning 'deeper.'", effect: null },
    { text: 'Your reflection in the obsidian wall reaches out and touches the glass from the other side. Where its fingers press, cracks appear.', log: 'Your reflection moves independently in the obsidian.', effect: null },
    { text: "Time skips. You are ten paces ahead of where you were, and your torch has burned down an hour's worth.", log: 'You lose time \u2014 your torch has burned down significantly.', effect: null },
    { text: 'Runes on the wall flare to life, pulsing in sequence toward the deeper floors, as if pointing the way.', log: 'Runes flare to life, pointing deeper.', effect: null },
    { text: 'A tremor shakes loose a stone from the ceiling. Beneath it: a single gold coin pressed into the rock, impossibly old.', log: 'A tremor shakes loose a hidden coin.', effect: 'coin2' },
    { text: 'The shadows in this room do not match the objects that cast them. They belong to furniture and figures that are not here.', log: 'Shadows in this room belong to things that aren\'t here.', effect: null },
    { text: 'You hear your own voice, ahead of you in the corridor, saying words you have not spoken yet.', log: 'You hear your own voice speaking ahead of you.', effect: null },
    { text: 'The heat intensifies for a moment, and you smell something vast and reptilian. It passes.', log: 'A wave of reptilian heat washes over you.', effect: null }
  ],
  // Tier 3: Floor 10 — Dragon's domain
  [
    { text: 'A scale the size of a shield falls from the ceiling and shatters like glass at your feet.', log: 'A massive dragon scale falls and shatters.', effect: null },
    { text: 'The gold beneath your feet shifts and settles. Something beneath the hoard is breathing.', log: "The gold hoard shifts with something's breathing.", effect: null },
    { text: "A skeleton in adventurer's gear sits against the wall. In its hand, a note: 'It sleeps with one eye open.'", log: "A dead adventurer's note warns: it sleeps with one eye open.", effect: null },
    { text: 'The walls exhale heat. For a moment, you see the outline of something colossal pressed against the stone, as if the mountain itself is the dragon.', log: 'Heat pulses from the walls in a vast silhouette.', effect: null },
    { text: 'Coins rain from the ceiling. When they land, they are already warm. Everything here belongs to the dragon.', log: 'Warm coins rain from the ceiling.', effect: 'coin3' },
    { text: 'A door slams shut behind you. When you turn, there is no door. There never was a door.', log: 'A door slams shut behind you \u2014 but there is no door.', effect: null },
    { text: 'The air itself seems to vibrate with a low, endless growl. Not a warning. A welcome.', log: 'A vast growl fills the air. It sounds welcoming.', effect: null },
    { text: "You find words burned into the floor: 'SHE REMEMBERS EVERY ONE OF YOU.'", log: "Burned into the floor: 'SHE REMEMBERS EVERY ONE OF YOU.'", effect: null }
  ]
];

// ════════════════════════════════════════════════════
// SECTION 3: UTILITY FUNCTIONS
// ════════════════════════════════════════════════════

function rand(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
function rollDie(sides) { return rand(1, sides); }
function rollDice(n, sides, bonus) { let t = bonus || 0; for (let i = 0; i < n; i++) t += rollDie(sides); return t; }
function rollDmg(dmg) { return rollDice(dmg[0], dmg[1], dmg[2]); }
function statMod(val) { return Math.floor((val - 10) / 2); }
function modStr(v) { return v >= 0 ? '+' + v : '' + v; }
function dist(x1, y1, x2, y2) { return Math.sqrt((x2-x1)**2 + (y2-y1)**2); }
function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
function pick(arr) { return arr[rand(0, arr.length - 1)]; }
function shuffle(arr) { for (let i = arr.length - 1; i > 0; i--) { const j = rand(0, i); [arr[i], arr[j]] = [arr[j], arr[i]]; } return arr; }

function roll4d6drop() {
  const rolls = [rollDie(6), rollDie(6), rollDie(6), rollDie(6)];
  rolls.sort((a,b) => a - b);
  return rolls[1] + rolls[2] + rolls[3];
}

// ════════════════════════════════════════════════════
// SECTION 4: AUDIO ENGINE
// ════════════════════════════════════════════════════

let audioCtx = null;
function initAudio() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  if (audioCtx.state === 'suspended') audioCtx.resume();
}

function playNote(freq, type, duration, vol, delay) {
  if (!audioCtx) return;
  vol = vol || 0.06;
  delay = delay || 0;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = type;
  osc.frequency.value = freq;
  gain.gain.setValueAtTime(0, audioCtx.currentTime + delay);
  gain.gain.linearRampToValueAtTime(vol, audioCtx.currentTime + delay + 0.01);
  gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + delay + duration);
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.start(audioCtx.currentTime + delay);
  osc.stop(audioCtx.currentTime + delay + duration + 0.05);
}

function sfxHit()      { playNote(220,'sawtooth',0.08,0.05); playNote(330,'square',0.05,0.04,0.03); }
function sfxMiss()     { playNote(150,'triangle',0.12,0.03); }
function sfxPlayerHit(){ playNote(110,'sawtooth',0.15,0.07); playNote(90,'sawtooth',0.2,0.05,0.1); }
function sfxKill()     { playNote(440,'square',0.05,0.04); playNote(550,'square',0.05,0.04,0.05); playNote(660,'square',0.08,0.04,0.1); }
function sfxPickup()   { playNote(523,'sine',0.06,0.04); playNote(659,'sine',0.06,0.04,0.06); }
function sfxGold()     { playNote(880,'sine',0.04,0.04); playNote(1108,'sine',0.04,0.04,0.04); playNote(1320,'sine',0.06,0.04,0.08); }
function sfxStairs()   { for(let i=0;i<6;i++) playNote(200+i*80,'sine',0.1,0.03,i*0.06); }
function sfxLevelUp()  { [523,659,784,1047].forEach((f,i) => playNote(f,'sine',0.15,0.06,i*0.12)); }
function sfxDeath()    { [220,196,165,147,110].forEach((f,i) => playNote(f,'sawtooth',0.3,0.07,i*0.2)); }
function sfxStep()     { playNote(100+Math.random()*40,'triangle',0.03,0.015); }
function sfxDiceRoll() { for(let i=0;i<8;i++) playNote(800+Math.random()*400,'square',0.02,0.02,i*0.07); }
function sfxCritical() { [880,1108,1320,1760].forEach((f,i) => playNote(f,'sawtooth',0.12,0.06,i*0.06)); playNote(440,'sine',0.3,0.04,0.3); }
function sfxLoreOpen() { playNote(330,'sine',0.2,0.03); playNote(440,'sine',0.15,0.025,0.1); playNote(392,'sine',0.3,0.02,0.2); }
function sfxEnvironmental() { playNote(80,'sine',0.5,0.02); playNote(120,'triangle',0.4,0.015,0.1); playNote(90,'sine',0.6,0.01,0.2); }

// ── OLD-SCHOOL DUNGEON MUSIC ──
// Procedural dark ambient / chiptune music that gets darker as you descend
let musicPlaying = false;
let musicTimeout = null;
let musicNodes = [];      // active drone oscillators
let musicMasterGain = null;
let musicMuted = false;

// Minor-key note sets per depth tier (frequencies in Hz)
// Gets progressively lower and more dissonant as you go deeper
const MUSIC_SCALES = [
  // Tier 0: Floors 1-3 — A minor, eerie but recognizable
  [110, 130.81, 146.83, 164.81, 196, 220, 261.63],
  // Tier 1: Floors 4-6 — D minor, darker, lower
  [73.42, 87.31, 98, 110, 130.81, 146.83, 164.81],
  // Tier 2: Floors 7-9 — Diminished / dissonant, rumbling
  [55, 65.41, 73.42, 82.41, 92.50, 103.83, 110],
  // Tier 3: Floor 10 — Deep tritone dread
  [41.20, 46.25, 55, 61.74, 69.30, 82.41, 92.50]
];

// Arpeggio patterns (index into scale)
const MUSIC_PATTERNS = [
  [0, 2, 4, 2],          // simple minor triad walk
  [0, 3, 4, 6, 4, 3],    // ascending / descending
  [0, 4, 2, 5, 0, 3],    // darker leaps
  [0, 1, 0, 2, 0, 3],    // creeping chromatic
  [6, 4, 2, 0],           // descending doom
  [0, 2, 0, 4, 0, 6],    // pedal tone with rising
];

function getMusicTier(floor) {
  if (floor <= 3) return 0;
  if (floor <= 6) return 1;
  if (floor <= 9) return 2;
  return 3;
}

function startMusic(floorLevel) {
  if (!audioCtx || musicMuted) return;
  stopMusic();
  musicPlaying = true;

  // Master gain for music — keep it quiet, atmospheric
  musicMasterGain = audioCtx.createGain();
  musicMasterGain.gain.value = 0.035;
  musicMasterGain.connect(audioCtx.destination);

  const tier = getMusicTier(floorLevel);
  const scale = MUSIC_SCALES[tier];

  // Layer 1: Low drone — fundamental bass note
  const droneFreq = scale[0];
  startDrone(droneFreq, 'triangle', 0.6);
  // Second drone a fifth above, quieter
  startDrone(droneFreq * 1.498, 'sine', 0.2); // slightly detuned fifth for unease

  // Layer 2: Slow arpeggio — square wave melody
  const pattern = MUSIC_PATTERNS[Math.floor(Math.random() * MUSIC_PATTERNS.length)];
  const tempo = 800 + tier * 200; // slower as you go deeper
  let step = 0;
  function playArpStep() {
    if (!musicPlaying) return;
    const noteIdx = pattern[step % pattern.length];
    const freq = scale[noteIdx] * 2; // one octave up from bass
    // Occasional octave jump for variety
    const oct = Math.random() < 0.15 ? 2 : 1;
    playMusicNote(freq * oct, 'square', tempo / 1000 * 0.6, 0.12);
    // Occasional harmony note
    if (Math.random() < 0.3) {
      const harmIdx = (noteIdx + 2) % scale.length;
      playMusicNote(scale[harmIdx] * 2 * oct, 'triangle', tempo / 1000 * 0.4, 0.06);
    }
    step++;
    // Every 8 steps, chance to switch pattern
    if (step % 8 === 0 && Math.random() < 0.4) {
      step = 0;
    }
    // Occasional silence for tension
    const nextDelay = Math.random() < 0.12 ? tempo * 2 : tempo;
    musicTimeout = setTimeout(playArpStep, nextDelay);
  }
  // Start arp after a brief pause
  musicTimeout = setTimeout(playArpStep, 1500);

  // Layer 3: Random eerie accents — very sparse
  startAccents(scale, tier);
}

function startDrone(freq, type, vol) {
  if (!audioCtx || !musicMasterGain) return;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = type;
  osc.frequency.value = freq;
  // Slow LFO for subtle wobble
  const lfo = audioCtx.createOscillator();
  const lfoGain = audioCtx.createGain();
  lfo.frequency.value = 0.3 + Math.random() * 0.4;
  lfoGain.gain.value = freq * 0.008; // very subtle pitch wobble
  lfo.connect(lfoGain);
  lfoGain.connect(osc.frequency);
  lfo.start();

  gain.gain.value = vol;
  osc.connect(gain);
  gain.connect(musicMasterGain);
  osc.start();
  musicNodes.push(osc, lfo, gain);
}

function playMusicNote(freq, type, duration, vol) {
  if (!audioCtx || !musicMasterGain) return;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = type;
  osc.frequency.value = freq;
  const t = audioCtx.currentTime;
  gain.gain.setValueAtTime(0, t);
  gain.gain.linearRampToValueAtTime(vol, t + 0.02);
  gain.gain.setValueAtTime(vol, t + duration * 0.7);
  gain.gain.exponentialRampToValueAtTime(0.001, t + duration);
  osc.connect(gain);
  gain.connect(musicMasterGain);
  osc.start(t);
  osc.stop(t + duration + 0.05);
}

let accentTimeout = null;
function startAccents(scale, tier) {
  function playAccent() {
    if (!musicPlaying) return;
    const roll = Math.random();
    if (roll < 0.4) {
      // High eerie tone
      const freq = scale[Math.floor(Math.random() * scale.length)] * 4;
      playMusicNote(freq, 'sine', 1.5 + Math.random(), 0.04);
    } else if (roll < 0.65) {
      // Low rumble
      playMusicNote(scale[0] * 0.5, 'sawtooth', 2 + Math.random() * 2, 0.05);
    } else if (roll < 0.8) {
      // Dissonant stab — two close frequencies
      const f = scale[Math.floor(Math.random() * scale.length)] * 2;
      playMusicNote(f, 'square', 0.3, 0.08);
      playMusicNote(f * 1.06, 'square', 0.3, 0.06); // dissonant
    }
    // else silence — nothing plays, adds tension
    const nextDelay = 3000 + Math.random() * 6000 + tier * 1000;
    accentTimeout = setTimeout(playAccent, nextDelay);
  }
  accentTimeout = setTimeout(playAccent, 2000 + Math.random() * 3000);
}

function stopMusic() {
  musicPlaying = false;
  if (musicTimeout) { clearTimeout(musicTimeout); musicTimeout = null; }
  if (accentTimeout) { clearTimeout(accentTimeout); accentTimeout = null; }
  musicNodes.forEach(node => {
    try { node.stop ? node.stop() : node.disconnect(); } catch(e) {}
  });
  musicNodes = [];
  if (musicMasterGain) {
    try { musicMasterGain.disconnect(); } catch(e) {}
    musicMasterGain = null;
  }
}

function toggleMusic() {
  if (musicMuted) {
    musicMuted = false;
    startMusic(player.floorLevel);
    addLog('<span class="log-info">♫ Music on</span>');
  } else {
    musicMuted = true;
    stopMusic();
    addLog('<span class="log-info">♫ Music off</span>');
  }
}

// ════════════════════════════════════════════════════
// SECTION 5: GAME STATE
// ════════════════════════════════════════════════════

const GS = {
  TITLE:'title', CHAR_CREATE:'charCreate', PLAYING:'playing',
  INVENTORY:'inventory', CHARACTER:'character', LEVEL_UP:'levelUp',
  TARGETING:'targeting', DEAD:'dead', HELP:'help', COMBAT:'combat', LORE:'lore'
};

let gameState = GS.TITLE;
let currentMap = null;
let currentRooms = [];
let monsters = [];
let items = [];
let floors = {};

let player = null;
let messageLog = [];

// Character creation state
let createStep = 0; // 0=name, 1=race, 2=class, 3=stats
let createData = { name:'', race:null, cls:null, stats:null, rerolls:3 };

// Combat overlay state
let combatMonster = null;
let combatPhase = 'idle'; // idle, player_roll, player_result, monster_roll, monster_result, ended
let combatAnimating = false;
let seenMonsters = new Set();
let visitedRooms = new Set();

// Lore overlay state
let currentLoreItem = null;
let loreTimer = null;

// ════════════════════════════════════════════════════
// SECTION 6: DUNGEON GENERATION
// ════════════════════════════════════════════════════

function createTile(type) { return { type: type, explored: false, visible: false }; }

function generateFloor(floorLevel) {
  const map = [];
  for (let y = 0; y < MAP_H; y++) {
    map[y] = [];
    for (let x = 0; x < MAP_W; x++) {
      map[y][x] = createTile(TILE.WALL);
    }
  }
  const rooms = [];

  function carveRoom(rx, ry, rw, rh) {
    for (let y = ry; y < ry + rh; y++)
      for (let x = rx; x < rx + rw; x++)
        map[y][x].type = TILE.FLOOR;
    rooms.push({ x:rx, y:ry, w:rw, h:rh, cx: rx + Math.floor(rw/2), cy: ry + Math.floor(rh/2) });
  }

  function carveCorridor(x1, y1, x2, y2) {
    let x = x1, y = y1;
    if (Math.random() < 0.5) {
      while (x !== x2) { if (map[y][x].type === TILE.WALL) map[y][x].type = TILE.FLOOR; x += x < x2 ? 1 : -1; }
      while (y !== y2) { if (map[y][x].type === TILE.WALL) map[y][x].type = TILE.FLOOR; y += y < y2 ? 1 : -1; }
    } else {
      while (y !== y2) { if (map[y][x].type === TILE.WALL) map[y][x].type = TILE.FLOOR; y += y < y2 ? 1 : -1; }
      while (x !== x2) { if (map[y][x].type === TILE.WALL) map[y][x].type = TILE.FLOOR; x += x < x2 ? 1 : -1; }
    }
    if (map[y2][x2].type === TILE.WALL) map[y2][x2].type = TILE.FLOOR;
  }

  function splitBSP(sx, sy, sw, sh, depth) {
    if (sw < 12 || sh < 10 || depth > 5) {
      const rw = rand(4, Math.min(sw - 2, 12));
      const rh = rand(3, Math.min(sh - 2, 8));
      const rx = sx + rand(1, sw - rw - 1);
      const ry = sy + rand(1, sh - rh - 1);
      carveRoom(rx, ry, rw, rh);
      return rooms[rooms.length - 1];
    }

    let r1, r2;
    if (sw > sh || (sw === sh && Math.random() < 0.5)) {
      const split = sx + rand(Math.floor(sw * 0.3), Math.floor(sw * 0.7));
      r1 = splitBSP(sx, sy, split - sx, sh, depth + 1);
      r2 = splitBSP(split, sy, sx + sw - split, sh, depth + 1);
    } else {
      const split = sy + rand(Math.floor(sh * 0.3), Math.floor(sh * 0.7));
      r1 = splitBSP(sx, sy, sw, split - sy, depth + 1);
      r2 = splitBSP(sx, split, sw, sy + sh - split, depth + 1);
    }

    if (r1 && r2) carveCorridor(r1.cx, r1.cy, r2.cx, r2.cy);
    return Math.random() < 0.5 ? r1 : r2;
  }

  splitBSP(1, 1, MAP_W - 2, MAP_H - 2, 0);

  // Place doors where corridors meet rooms (sparse)
  for (let y = 2; y < MAP_H - 2; y++) {
    for (let x = 2; x < MAP_W - 2; x++) {
      if (map[y][x].type !== TILE.FLOOR) continue;
      const h = map[y][x-1].type === TILE.WALL && map[y][x+1].type === TILE.WALL &&
                map[y-1][x].type === TILE.FLOOR && map[y+1][x].type === TILE.FLOOR;
      const v = map[y-1][x].type === TILE.WALL && map[y+1][x].type === TILE.WALL &&
                map[y][x-1].type === TILE.FLOOR && map[y][x+1].type === TILE.FLOOR;
      if ((h || v) && Math.random() < 0.15) map[y][x].type = TILE.DOOR;
    }
  }

  // Place stairs
  if (rooms.length > 1) {
    const spawnRoom = rooms[0];
    // Find room furthest from spawn
    let farthest = rooms[1], maxD = 0;
    for (let i = 1; i < rooms.length; i++) {
      const d = dist(spawnRoom.cx, spawnRoom.cy, rooms[i].cx, rooms[i].cy);
      if (d > maxD) { maxD = d; farthest = rooms[i]; }
    }
    if (floorLevel < MAX_FLOORS) {
      map[farthest.cy][farthest.cx].type = TILE.STAIRS_DOWN;
    }
    if (floorLevel > 1) {
      map[spawnRoom.cy][spawnRoom.cx].type = TILE.STAIRS_UP;
    }
  }

  // Place traps (floor 3+)
  if (floorLevel >= 3) {
    const numTraps = rand(1, Math.min(floorLevel - 1, 4));
    for (let t = 0; t < numTraps; t++) {
      const room = pick(rooms);
      const tx = rand(room.x + 1, room.x + room.w - 2);
      const ty = rand(room.y + 1, room.y + room.h - 2);
      if (map[ty][tx].type === TILE.FLOOR) {
        map[ty][tx].type = TILE.TRAP;
        map[ty][tx].revealed = false;
      }
    }
  }

  return { map, rooms };
}

// ════════════════════════════════════════════════════
// SECTION 7: FOV / SHADOWCASTING
// ════════════════════════════════════════════════════

function computeFOV(map, px, py, radius) {
  for (let y = 0; y < MAP_H; y++)
    for (let x = 0; x < MAP_W; x++)
      map[y][x].visible = false;

  map[py][px].visible = true;
  map[py][px].explored = true;

  const mult = [
    [1,0,0,-1,-1,0,0,1],
    [0,1,-1,0,0,-1,1,0],
    [0,1,1,0,0,-1,-1,0],
    [1,0,0,1,-1,0,0,-1]
  ];

  function castLight(row, startSlope, endSlope, octant) {
    if (startSlope < endSlope) return;
    let nextStart = startSlope;
    for (let i = row; i <= radius; i++) {
      let blocked = false;
      for (let dx = -i, dy = -i; dx <= 0; dx++) {
        const mapX = px + dx * mult[0][octant] + dy * mult[1][octant];
        const mapY = py + dx * mult[2][octant] + dy * mult[3][octant];
        if (mapX < 0 || mapX >= MAP_W || mapY < 0 || mapY >= MAP_H) continue;

        const lSlope = (dx - 0.5) / (dy + 0.5);
        const rSlope = (dx + 0.5) / (dy - 0.5);

        if (startSlope < rSlope) continue;
        if (endSlope > lSlope) break;

        const d = Math.sqrt(dx*dx + dy*dy);
        if (d <= radius) {
          map[mapY][mapX].visible = true;
          map[mapY][mapX].explored = true;
        }

        if (blocked) {
          if (map[mapY][mapX].type === TILE.WALL) {
            nextStart = rSlope;
            continue;
          } else {
            blocked = false;
            startSlope = nextStart;
          }
        } else if (map[mapY][mapX].type === TILE.WALL && i < radius) {
          blocked = true;
          castLight(i + 1, startSlope, lSlope, octant);
          nextStart = rSlope;
        }
      }
      if (blocked) break;
    }
  }

  for (let oct = 0; oct < 8; oct++) {
    castLight(1, 1.0, 0.0, oct);
  }
}

// ════════════════════════════════════════════════════
// SECTION 8: MONSTER MANAGEMENT
// ════════════════════════════════════════════════════

function spawnMonsters(rooms, floorLevel) {
  const spawned = [];
  const tierForFloor = floorLevel <= 3 ? 1 : floorLevel <= 6 ? 2 : floorLevel <= 9 ? 3 : 4;
  const available = Object.entries(BESTIARY).filter(([,m]) => m.tier <= tierForFloor);

  for (let i = 1; i < rooms.length; i++) {
    if (Math.random() > 0.2 + floorLevel * 0.03) continue;
    const room = rooms[i];
    const count = rand(1, Math.min(1 + Math.floor(floorLevel / 4), 2));
    for (let c = 0; c < count; c++) {
      const mx = rand(room.x + 1, room.x + room.w - 2);
      const my = rand(room.y + 1, room.y + room.h - 2);
      if (spawned.some(m => m.x === mx && m.y === my)) continue;
      const [key, template] = pick(available);
      spawned.push({
        ...template, id: key + '_' + spawned.length,
        x: mx, y: my, curHp: template.hp, maxHp: template.hp,
        aware: false, lastSawPlayer: null
      });
    }
  }
  return spawned;
}

function getMonsterAt(x, y) { return monsters.find(m => m.x === x && m.y === y && m.curHp > 0); }

// ════════════════════════════════════════════════════
// SECTION 9: ITEM MANAGEMENT
// ════════════════════════════════════════════════════

function spawnItems(rooms, floorLevel) {
  const spawned = [];

  for (let i = 0; i < rooms.length; i++) {
    if (Math.random() > 0.5) continue;
    const room = rooms[i];
    const count = rand(1, 2);
    for (let c = 0; c < count; c++) {
      const ix = rand(room.x + 1, room.x + room.w - 2);
      const iy = rand(room.y + 1, room.y + room.h - 2);
      if (spawned.some(it => it.x === ix && it.y === iy)) continue;

      const roll = Math.random();
      let item;
      if (roll < 0.25) {
        // Gold
        item = { type:'gold', name:'Bitcoin', ch:'\u20BF', color:'#f7931a', amount: rollDice(floorLevel, 6, floorLevel * 2), x:ix, y:iy };
      } else if (roll < 0.6) {
        // Potion — weighted toward healing
        const potionRoll = Math.random();
        const p = potionRoll < 0.6 ? POTIONS[0] : potionRoll < 0.8 ? POTIONS[1] : pick(POTIONS);
        item = { ...p, type:'potion', x:ix, y:iy };
      } else if (roll < 0.7) {
        // Scroll
        const s = pick(SCROLLS);
        item = { ...s, type:'scroll', x:ix, y:iy };
      } else if (roll < 0.85) {
        // Weapon
        const w = pick(WEAPONS.filter(w => w.value <= floorLevel * 15 + 20));
        const enchant = floorLevel >= 5 && Math.random() < 0.2 ? rand(1, Math.min(3, Math.floor(floorLevel/3))) : 0;
        item = { ...w, type:'weapon', enchant, x:ix, y:iy, color: enchant ? '#aa44ff' : '#44aacc' };
        if (enchant) item.name = item.name + ' +' + enchant;
      } else {
        // Armor
        const a = pick(ARMORS.filter(a => a.value <= floorLevel * 30 + 30));
        const enchant = floorLevel >= 5 && Math.random() < 0.2 ? rand(1, Math.min(3, Math.floor(floorLevel/3))) : 0;
        item = { ...a, type:'armor', enchant, x:ix, y:iy, color: enchant ? '#aa44ff' : '#44aacc' };
        if (enchant) item.name = item.name + ' +' + enchant;
      }
      spawned.push(item);
    }
  }

  // Spawn lore scroll for this floor (one per floor, in a non-starting room)
  const loreEntry = LORE_SCROLLS.find(l => l.floor === floorLevel);
  if (loreEntry) {
    const loreRooms = rooms.filter((r, i) => i > 0);
    if (loreRooms.length > 0) {
      const room = pick(loreRooms);
      const lx = rand(room.x + 1, room.x + room.w - 2);
      const ly = rand(room.y + 1, room.y + room.h - 2);
      spawned.push({
        type: 'lore', name: loreEntry.name, title: loreEntry.title,
        text: loreEntry.text, floor: loreEntry.floor,
        ch: loreEntry.ch, color: loreEntry.color, value: 0, x: lx, y: ly
      });
    }
  }

  return spawned;
}

function getItemAt(x, y) { return items.find(it => it.x === x && it.y === y); }

// ════════════════════════════════════════════════════
// SECTION 10: PLAYER & COMBAT
// ════════════════════════════════════════════════════

function createPlayer(name, raceKey, clsKey, stats) {
  const race = RACES[raceKey];
  const cls = CLASSES[clsKey];
  const finalStats = {};
  for (const s of ['str','dex','con','int','wis']) {
    finalStats[s] = stats[s] + (race.mods[s] || 0);
  }
  const maxHp = cls.hitDie + statMod(finalStats.con);
  const maxMana = (clsKey === 'mage' || clsKey === 'cleric') ? 4 + statMod(finalStats.int) + statMod(finalStats.wis) : 0;

  // Starting equipment
  const weapon = WEAPONS.find(w => w.name === cls.startWeapon);
  const armor = ARMORS.find(a => a.name === cls.startArmor);

  return {
    name, race: raceKey, cls: clsKey, level: 1, xp: 0,
    xpToLevel: 150,
    stats: finalStats,
    hp: maxHp, maxHp,
    mana: maxMana, maxMana,
    ac: 10 + (armor ? armor.acBonus : 0) + Math.min(statMod(finalStats.dex), armor ? armor.dexCap : 99),
    inventory: [],
    equipment: {
      weapon: weapon ? { ...weapon, type:'weapon', enchant:0 } : null,
      armor: armor ? { ...armor, type:'armor', enchant:0 } : null,
      shield: null, ring: null, amulet: null
    },
    x: 0, y: 0,
    floorLevel: 1,
    visionRadius: raceKey === 'dwarf' ? 10 : 8,
    conditions: [],
    turnsPlayed: 0, monstersKilled: 0, goldCollected: 0, deepestFloor: 1,
    luckyUsed: false, // Halfling
    lastCombatTurn: 0, // Track last turn combat occurred for natural regen
    healsRemaining: clsKey === 'cleric' ? 3 : 0,
    spells: clsKey === 'mage' ? ['Magic Missile', 'Frost Ray', 'Fireball'] : [],
    cleaveTarget: null
  };
}

function getPlayerAttackMod() {
  const w = player.equipment.weapon;
  const primaryStat = w && w.stat ? w.stat : 'str';
  const prof = Math.min(6, Math.floor(player.level / 4) + 2);
  return statMod(player.stats[primaryStat]) + prof + (w && w.enchant ? w.enchant : 0);
}

function getPlayerDamage() {
  const w = player.equipment.weapon;
  const dmg = w ? w.dmg : [1, 4, 0];
  const primaryStat = w && w.stat ? w.stat : 'str';
  return rollDmg(dmg) + statMod(player.stats[primaryStat]) + (w && w.enchant ? w.enchant : 0);
}

function recalcAC() {
  const a = player.equipment.armor;
  const s = player.equipment.shield;
  const dexMod = statMod(player.stats.dex);
  const dexCap = a ? a.dexCap : 99;
  player.ac = 10 + (a ? a.acBonus + (a.enchant || 0) : 0) + Math.min(dexMod, dexCap) + (s ? 2 : 0);
}

function attackMonster(monster) {
  player.lastCombatTurn = player.turnsPlayed;
  const roll = rollDie(20);
  const mod = getPlayerAttackMod();
  const total = roll + mod;
  const hit = roll === 20 || (roll !== 1 && total >= monster.ac);
  const crit = roll === 20;

  if (roll === 1) {
    addLog(`You swing wildly at the ${monster.name}... <span class="log-miss">(nat 1) MISS!</span>`);
    sfxMiss();
    return false;
  }

  if (hit) {
    let dmg = getPlayerDamage();
    if (crit) dmg += getPlayerDamage(); // double on crit
    dmg = Math.max(1, dmg);
    monster.curHp -= dmg;
    const rollStr = `<span class="log-info">(${roll}${crit ? '!!' : ''} + ${mod} = ${total} vs AC ${monster.ac})</span>`;
    if (monster.curHp <= 0) {
      addLog(`You strike the ${monster.name}! ${rollStr} <span class="log-damage">${dmg} dmg</span> — <span class="log-kill">SLAIN!</span>`);
      const xpGain = Math.floor(monster.xp * (player.race === 'human' ? 1.1 : 1));
      player.xp += xpGain;
      player.monstersKilled++;
      addLog(`<span class="log-xp">+${xpGain} XP</span>`);
      sfxKill();
      return 'killed';
    } else {
      addLog(`You hit the ${monster.name}! ${rollStr} <span class="log-damage">${dmg} dmg</span> (${monster.curHp}/${monster.maxHp})`);
      sfxHit();
    }
  } else {
    addLog(`You miss the ${monster.name}. <span class="log-info">(${roll} + ${mod} = ${total} vs AC ${monster.ac})</span> <span class="log-miss">MISS</span>`);
    sfxMiss();
  }
  return hit ? true : false;
}

function monsterAttackPlayer(monster) {
  player.lastCombatTurn = player.turnsPlayed;
  const roll = rollDie(20);
  const total = roll + monster.atk;
  const hit = roll === 20 || (roll !== 1 && total >= player.ac);

  if (hit) {
    let dmg = rollDmg(monster.dmg);
    if (roll === 20) dmg += rollDmg(monster.dmg);
    dmg = Math.max(1, dmg);
    player.hp -= dmg;
    addLog(`The ${monster.name} hits you! <span class="log-player-hit">${dmg} dmg</span> (HP: ${Math.max(0,player.hp)}/${player.maxHp})`);
    sfxPlayerHit();

    // Special effects
    if (monster.special === 'poison' && Math.random() < 0.3) {
      const save = rollDie(20) + statMod(player.stats.con);
      if (save < 12 + player.floorLevel) {
        player.conditions.push({ type:'poisoned', duration: 5, dmg: 1 });
        addLog(`<span class="log-player-hit">You are poisoned!</span>`);
      }
    }
    if (monster.special === 'drain') {
      const drainHp = rand(1, 3);
      monster.curHp = Math.min(monster.maxHp, monster.curHp + drainHp);
      addLog(`<span class="log-player-hit">The ${monster.name} drains your life force!</span>`);
    }
  } else {
    addLog(`The ${monster.name} misses you. <span class="log-miss">(${roll} + ${monster.atk} = ${total} vs AC ${player.ac})</span>`);
  }
}

// ════════════════════════════════════════════════════
// SECTION 11: MONSTER AI
// ════════════════════════════════════════════════════

function processMonsterTurns() {
  for (const m of monsters) {
    if (m.curHp <= 0) continue;
    if (combatMonster && m.id === combatMonster.id) continue; // Handled by combat overlay

    // Regen
    if (m.special === 'regen' && m.curHp < m.maxHp) {
      m.curHp = Math.min(m.maxHp, m.curHp + 2);
    }

    const d = dist(m.x, m.y, player.x, player.y);
    const canSee = currentMap[m.y][m.x].visible; // if player can see it, it can "see" player

    if (canSee) { m.aware = true; m.lastSawPlayer = { x: player.x, y: player.y }; }

    // Adjacent? Attack!
    if (Math.abs(m.x - player.x) <= 1 && Math.abs(m.y - player.y) <= 1 && !(m.x === player.x && m.y === player.y)) {
      // Dragon breath weapon
      if (m.special === 'breath' && Math.random() < 0.3) {
        const save = rollDie(20) + statMod(player.stats.dex);
        const dmg = rollDice(4, 6, 0);
        if (save < 15) {
          player.hp -= dmg;
          addLog(`<span class="log-player-hit">The ${m.name} breathes fire! ${dmg} damage!</span>`);
        } else {
          player.hp -= Math.floor(dmg / 2);
          addLog(`<span class="log-player-hit">The ${m.name} breathes fire! You dodge partially — ${Math.floor(dmg/2)} damage!</span>`);
        }
        sfxPlayerHit();
      } else {
        monsterAttackPlayer(m);
      }
      continue;
    }

    // Movement AI
    if (m.behavior === 'stationary' && !m.aware) continue;

    let target = null;
    if (m.aware && m.behavior !== 'flee') {
      target = { x: player.x, y: player.y };
    } else if (m.behavior === 'flee' && m.curHp < m.maxHp * 0.25 && canSee) {
      // Run away
      const dx = m.x - player.x;
      const dy = m.y - player.y;
      target = { x: m.x + Math.sign(dx), y: m.y + Math.sign(dy) };
    } else if (m.behavior === 'wander') {
      const dirs = [[0,1],[0,-1],[1,0],[-1,0]];
      const d = pick(dirs);
      target = { x: m.x + d[0], y: m.y + d[1] };
    }

    if (target) {
      const dx = Math.sign(target.x - m.x);
      const dy = Math.sign(target.y - m.y);
      const nx = m.x + dx;
      const ny = m.y + dy;

      if (nx >= 0 && nx < MAP_W && ny >= 0 && ny < MAP_H &&
          currentMap[ny][nx].type !== TILE.WALL &&
          !getMonsterAt(nx, ny) &&
          !(nx === player.x && ny === player.y)) {
        m.x = nx;
        m.y = ny;
      }
    }
  }
}

// ════════════════════════════════════════════════════
// SECTION 12: RENDERING
// ════════════════════════════════════════════════════

function renderMap() {
  const mapEl = document.getElementById('dungeon-map');
  const offsetX = clamp(player.x - Math.floor(VIEW_W/2), 0, MAP_W - VIEW_W);
  const offsetY = clamp(player.y - Math.floor(VIEW_H/2), 0, MAP_H - VIEW_H);

  let html = '';
  for (let vy = 0; vy < VIEW_H; vy++) {
    for (let vx = 0; vx < VIEW_W; vx++) {
      const mx = offsetX + vx;
      const my = offsetY + vy;
      if (mx >= MAP_W || my >= MAP_H) { html += ' '; continue; }
      const tile = currentMap[my][mx];

      if (!tile.explored) { html += '<span class="t-void"> </span>'; continue; }

      const monster = getMonsterAt(mx, my);
      const item = getItemAt(mx, my);
      const isPlayer = mx === player.x && my === player.y;

      if (tile.visible) {
        const d = dist(mx, my, player.x, player.y);
        const bright = Math.max(0.35, 1.0 - (d / player.visionRadius) * 0.65);

        if (isPlayer) {
          html += '<span class="t-player">@</span>';
        } else if (monster) {
          html += `<span style="color:${monster.color};opacity:${bright}">${monster.ch}</span>`;
        } else if (item) {
          html += `<span style="color:${item.color || '#44aacc'};opacity:${bright}">${item.ch}</span>`;
        } else {
          const ch = tile.type === TILE.TRAP && !tile.revealed ? '\u00B7' : TILE_CH[tile.type];
          const cls = tile.type === TILE.TRAP && !tile.revealed ? 't-floor' : TILE_CLASS[tile.type];
          html += `<span class="${cls}" style="opacity:${bright}">${ch}</span>`;
        }
      } else {
        // Explored but not visible — dim memory
        const ch = tile.type === TILE.TRAP && !tile.revealed ? '\u00B7' : TILE_CH[tile.type];
        const cls = tile.type === TILE.TRAP && !tile.revealed ? 't-floor' : TILE_CLASS[tile.type];
        html += `<span class="${cls}" style="opacity:0.2">${ch}</span>`;
      }
    }
    html += '\n';
  }
  mapEl.innerHTML = html;
}

function renderStats() {
  if (!player) return;
  const p = player;
  const hpPct = Math.max(0, p.hp / p.maxHp * 100);
  const hpClass = hpPct > 50 ? 'hp' : hpPct > 25 ? 'hp warn' : 'hp danger';

  let html = `<h2>${p.name}</h2>`;
  html += `<div class="class-race">Level ${p.level} ${RACES[p.race].name} ${CLASSES[p.cls].name}</div>`;

  // HP Bar
  html += `<div class="bar-container">
    <div class="bar-label"><span>HP</span><span>${Math.max(0,p.hp)} / ${p.maxHp}</span></div>
    <div class="bar-track"><div class="bar-fill ${hpClass}" style="width:${hpPct}%"></div></div></div>`;

  // Mana bar (if applicable)
  if (p.maxMana > 0) {
    const manaPct = Math.max(0, p.mana / p.maxMana * 100);
    html += `<div class="bar-container">
      <div class="bar-label"><span>Mana</span><span>${p.mana} / ${p.maxMana}</span></div>
      <div class="bar-track"><div class="bar-fill mana" style="width:${manaPct}%"></div></div></div>`;
  }

  // XP bar
  const xpPct = Math.min(100, p.xp / p.xpToLevel * 100);
  html += `<div class="bar-container">
    <div class="bar-label"><span>XP</span><span>${p.xp} / ${p.xpToLevel}</span></div>
    <div class="bar-track"><div class="bar-fill xp" style="width:${xpPct}%"></div></div></div>`;

  // Stats
  html += '<div class="stat-grid">';
  for (const s of ['str','dex','con','int','wis']) {
    const m = statMod(p.stats[s]);
    const modCls = m >= 0 ? 'pos' : 'neg';
    html += `<span class="stat-name">${s.toUpperCase()}</span><span class="stat-val">${p.stats[s]} <span class="stat-mod ${modCls}">(${modStr(m)})</span></span>`;
  }
  html += '</div>';

  // AC
  html += `<div style="font-size:11px;color:var(--text-dim);margin-bottom:8px;">AC: <span style="color:var(--text-bright)">${p.ac}</span> &nbsp; \u20BF: <span style="color:var(--item-gold)">${p.goldCollected}</span></div>`;

  // Equipment
  html += '<div class="equip-section"><h3>EQUIPMENT</h3>';
  const slots = ['weapon','armor','shield','ring','amulet'];
  for (const slot of slots) {
    const item = p.equipment[slot];
    if (item) {
      const cls = item.enchant ? 'item-magic' : 'item-name';
      html += `<div class="equip-slot"><span style="color:var(--text-faded)">${slot}:</span> <span class="${cls}">${item.name}</span></div>`;
    } else {
      html += `<div class="equip-slot"><span style="color:var(--text-faded)">${slot}: —</span></div>`;
    }
  }
  html += '</div>';

  // Conditions
  if (p.conditions.length > 0) {
    html += '<div class="conditions">';
    for (const c of p.conditions) {
      const cls = c.type === 'poisoned' ? 'debuff' : 'buff';
      html += `<span class="cond-badge ${cls}">${c.type} (${c.duration})</span> `;
    }
    html += '</div>';
  }

  document.getElementById('stats-content').innerHTML = html;
}

function renderMiniMap() {
  const canvas = document.getElementById('mini-map');
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = '#08080c';
  ctx.fillRect(0, 0, 80, 40);

  for (let y = 0; y < MAP_H; y++) {
    for (let x = 0; x < MAP_W; x++) {
      const tile = currentMap[y][x];
      if (!tile.explored) continue;
      if (tile.type === TILE.WALL) {
        ctx.fillStyle = tile.visible ? '#2a2a44' : '#161628';
      } else if (tile.type === TILE.STAIRS_DOWN || tile.type === TILE.STAIRS_UP) {
        ctx.fillStyle = '#ffffff';
      } else {
        ctx.fillStyle = tile.visible ? '#3a3a5c' : '#1a1a2e';
      }
      ctx.fillRect(x, y, 1, 1);
    }
  }

  // Monsters
  for (const m of monsters) {
    if (m.curHp > 0 && currentMap[m.y][m.x].visible) {
      ctx.fillStyle = m.color;
      ctx.fillRect(m.x, m.y, 1, 1);
    }
  }

  // Player
  ctx.fillStyle = '#f0c040';
  ctx.fillRect(player.x, player.y, 1, 1);
}

function renderSidebar() {
  let html = '';
  // Context hints
  const tile = currentMap[player.y][player.x];
  const itemHere = getItemAt(player.x, player.y);

  if (tile.type === TILE.STAIRS_DOWN) html += '<div class="hint-line"><kbd>&gt;</kbd> Descend stairs</div>';
  if (tile.type === TILE.STAIRS_UP) html += '<div class="hint-line"><kbd>&lt;</kbd> Ascend stairs</div>';
  if (itemHere) html += `<div class="hint-line"><kbd>g</kbd> Pick up ${itemHere.name}</div>`;

  // Adjacent monsters
  for (const m of monsters) {
    if (m.curHp > 0 && Math.abs(m.x - player.x) <= 1 && Math.abs(m.y - player.y) <= 1) {
      html += `<div class="hint-line" style="color:${m.color}">Adjacent: ${m.name} (${m.curHp}/${m.maxHp})</div>`;
    }
  }

  html += '<div style="margin-top:8px;border-top:1px solid var(--border);padding-top:6px;">';
  html += '<div class="hint-line"><kbd>Arrows/hjkl</kbd> Move</div>';
  html += '<div class="hint-line"><kbd>yubn</kbd> Diagonal</div>';
  html += '<div class="hint-line"><kbd>.</kbd> Wait</div>';
  html += '<div class="hint-line"><kbd>g</kbd> Pick up</div>';
  html += '<div class="hint-line"><kbd>i</kbd> Inventory</div>';
  html += '<div class="hint-line"><kbd>m</kbd> Music</div>';
  html += '<div class="hint-line"><kbd>?</kbd> Help</div>';
  html += '</div>';

  document.getElementById('hints-content').innerHTML = html;
}

function addLog(msg) {
  messageLog.push(msg);
  if (messageLog.length > 200) messageLog.shift();
  const el = document.getElementById('message-log');
  const div = document.createElement('div');
  div.className = 'log-entry';
  div.innerHTML = msg;
  el.prepend(div);
  el.parentElement.scrollTop = 0;
}

let cinematicTimer = null;
let narrativeQueue = [];
function addNarrative(msg) {
  // If a cinematic is already playing, queue this one
  if (cinematicTimer) {
    narrativeQueue.push(msg);
    // Still add to log immediately
    const el = document.getElementById('message-log');
    const logDiv = document.createElement('div');
    logDiv.className = 'log-entry narrative';
    logDiv.textContent = msg;
    el.prepend(logDiv);
    el.parentElement.scrollTop = 0;
    return;
  }

  // Add to log immediately (as italic narrative)
  const el = document.getElementById('message-log');
  const logDiv = document.createElement('div');
  logDiv.className = 'log-entry narrative';
  logDiv.textContent = msg;
  el.prepend(logDiv);
  el.parentElement.scrollTop = 0;

  // Cinematic overlay — typewriter across the map, then fade
  playNarrativeCinematic(msg);
}

function playNarrativeCinematic(msg) {
  const cine = document.getElementById('cine-inner');
  cine.textContent = '';
  cine.className = 'cine-inner visible';
  let i = 0;
  function typeCine() {
    if (i < msg.length) {
      cine.textContent += msg[i++];
      cinematicTimer = setTimeout(typeCine, 30 + Math.random() * 20);
    } else {
      // Hold for a moment, then fade out
      cinematicTimer = setTimeout(() => {
        cine.className = 'cine-inner fade-out';
        cinematicTimer = setTimeout(() => {
          cine.className = 'cine-inner';
          cine.textContent = '';
          cinematicTimer = null;
          // Play next queued narrative if any
          if (narrativeQueue.length > 0) {
            playNarrativeCinematic(narrativeQueue.shift());
          }
        }, 1600);
      }, 2000);
    }
  }
  typeCine();
}

function renderAll() {
  renderMap();
  renderStats();
  renderMiniMap();
  renderSidebar();
  document.getElementById('floor-name').textContent = FLOOR_NAMES[player.floorLevel] + ' \u2014 Floor ' + player.floorLevel;
  document.getElementById('turn-count').textContent = 'Turn ' + player.turnsPlayed;
  document.getElementById('char-brief').textContent = player.name + ' \u2022 Lv' + player.level;
}

// ════════════════════════════════════════════════════
// SECTION 13: FLOOR MANAGEMENT
// ════════════════════════════════════════════════════

function enterFloor(floorLevel, fromStairs) {
  player.floorLevel = floorLevel;
  if (floorLevel > player.deepestFloor) player.deepestFloor = floorLevel;

  // Reset Halfling luck per floor
  player.luckyUsed = false;
  // Reset room visit tracking for new floor
  visitedRooms = new Set();
  // Reset Cleric heals per floor
  if (player.cls === 'cleric') player.healsRemaining = 3 + Math.floor(player.level / 2);

  if (floors[floorLevel]) {
    // Revisiting a floor
    currentMap = floors[floorLevel].map;
    currentRooms = floors[floorLevel].rooms;
    monsters = floors[floorLevel].monsters;
    items = floors[floorLevel].items;
    // Place player at appropriate stairs
    if (fromStairs === 'down') {
      // Coming from above, place at stairs up
      for (let y = 0; y < MAP_H; y++)
        for (let x = 0; x < MAP_W; x++)
          if (currentMap[y][x].type === TILE.STAIRS_UP) { player.x = x; player.y = y; }
    } else {
      // Coming from below, place at stairs down
      for (let y = 0; y < MAP_H; y++)
        for (let x = 0; x < MAP_W; x++)
          if (currentMap[y][x].type === TILE.STAIRS_DOWN) { player.x = x; player.y = y; }
    }
  } else {
    const { map, rooms } = generateFloor(floorLevel);
    currentMap = map;
    currentRooms = rooms;
    monsters = spawnMonsters(rooms, floorLevel);
    items = spawnItems(rooms, floorLevel);

    // Place player in first room
    player.x = currentRooms[0].cx;
    player.y = currentRooms[0].cy;

    floors[floorLevel] = { map: currentMap, rooms: currentRooms, monsters, items };
  }

  computeFOV(currentMap, player.x, player.y, player.visionRadius);

  const desc = pick(FLOOR_DESCRIPTIONS[floorLevel] || FLOOR_DESCRIPTIONS[1]);
  setTimeout(() => addNarrative(desc), 300);

  // Restart music with new floor's tone
  if (musicPlaying || (!musicMuted && floorLevel >= 1)) {
    startMusic(floorLevel);
  }
}

function fadeTransition(callback) {
  const fade = document.getElementById('fade-overlay');
  fade.classList.add('active');
  sfxStairs();
  setTimeout(() => {
    callback();
    renderAll();
    setTimeout(() => fade.classList.remove('active'), 100);
  }, 500);
}

// ════════════════════════════════════════════════════
// SECTION 13B: COMBAT ENCOUNTER OVERLAY
// ════════════════════════════════════════════════════

function getMonsterKey(monster) {
  return monster.id.replace(/_\d+$/, '');
}

function startCombat(monster) {
  combatMonster = monster;
  combatPhase = 'idle';
  combatAnimating = false;
  gameState = GS.COMBAT;
  player.lastCombatTurn = player.turnsPlayed;

  const overlay = document.getElementById('combat-overlay');
  overlay.classList.remove('hidden');

  // Monster art and info
  const key = getMonsterKey(monster);
  const art = MONSTER_ART[key] || '';
  document.getElementById('combat-monster-art').textContent = art;
  document.getElementById('combat-monster-art').style.color = monster.color;
  document.getElementById('combat-monster-name').textContent = monster.name;
  document.getElementById('combat-monster-ac').textContent = 'AC ' + monster.ac;

  // Player info
  document.getElementById('combat-player-name').textContent = player.name;
  const wep = player.equipment.weapon;
  document.getElementById('combat-player-ac').textContent = 'AC ' + player.ac;
  document.getElementById('combat-player-weapon').textContent = wep ? wep.name : 'Unarmed';

  // Clear previous state
  document.getElementById('combat-dice').textContent = '?';
  document.getElementById('combat-dice').className = 'combat-dice';
  document.getElementById('combat-roll-math').textContent = '';
  document.getElementById('combat-result').textContent = '';
  document.getElementById('combat-result').className = 'combat-result';
  document.getElementById('combat-log').innerHTML = '';

  updateCombatHP();

  // Flavor text
  const flavorEl = document.getElementById('combat-flavor');
  if (!seenMonsters.has(key)) {
    seenMonsters.add(key);
    const flavors = MONSTER_FLAVOR[key] || [];
    flavorEl.textContent = flavors.length > 0 ? pick(flavors) : '';
  } else {
    // Short repeat text
    const shortFlavors = [
      `A ${monster.name} stands before you.`,
      `Another ${monster.name} blocks your path.`,
      `You face a ${monster.name} once more.`
    ];
    flavorEl.textContent = pick(shortFlavors);
  }

  document.getElementById('combat-prompt').textContent = 'Press SPACE to attack \u2022 ESC to flee';
  document.getElementById('combat-prompt').style.display = '';
}

function updateCombatHP() {
  if (!combatMonster) return;
  const m = combatMonster;
  const mPct = Math.max(0, (m.curHp / m.maxHp) * 100);
  document.getElementById('combat-monster-hp').style.width = mPct + '%';
  document.getElementById('combat-monster-hp-text').textContent = Math.max(0, m.curHp) + '/' + m.maxHp;

  const pPct = Math.max(0, (player.hp / player.maxHp) * 100);
  document.getElementById('combat-player-hp').style.width = pPct + '%';
  document.getElementById('combat-player-hp-text').textContent = Math.max(0, player.hp) + '/' + player.maxHp;
}

function animateDiceRoll(finalValue, duration, callback) {
  combatAnimating = true;
  const diceEl = document.getElementById('combat-dice');
  diceEl.className = 'combat-dice rolling';
  sfxDiceRoll();

  const interval = 60;
  let elapsed = 0;
  const timer = setInterval(() => {
    diceEl.textContent = rand(1, 20);
    elapsed += interval;
    if (elapsed >= duration) {
      clearInterval(timer);
      diceEl.textContent = finalValue;
      diceEl.className = 'combat-dice';
      if (finalValue === 20) diceEl.classList.add('crit');
      if (finalValue === 1) diceEl.classList.add('miss');
      combatAnimating = false;
      if (callback) callback();
    }
  }, interval);
}

function combatPlayerAttack() {
  if (combatAnimating) return;
  combatPhase = 'player_roll';
  document.getElementById('combat-prompt').style.display = 'none';
  document.getElementById('combat-result').textContent = '';
  document.getElementById('combat-result').className = 'combat-result';
  document.getElementById('combat-roll-math').textContent = '';
  document.getElementById('combat-log').innerHTML = '';

  const roll = rollDie(20);
  const mod = getPlayerAttackMod();
  const total = roll + mod;
  const monster = combatMonster;
  const hit = roll === 20 || (roll !== 1 && total >= monster.ac);
  const crit = roll === 20;
  const nat1 = roll === 1;

  animateDiceRoll(roll, 700, () => {
    // Show math
    document.getElementById('combat-roll-math').textContent =
      `${roll} + ${mod} = ${total} vs AC ${monster.ac}`;

    setTimeout(() => {
      combatPhase = 'player_result';
      const resultEl = document.getElementById('combat-result');
      const logEl = document.getElementById('combat-log');

      if (nat1) {
        resultEl.textContent = 'MISS!';
        resultEl.className = 'combat-result miss-result';
        sfxMiss();
        addLog(`You swing wildly at the ${monster.name}... <span class="log-miss">(nat 1) MISS!</span>`);
      } else if (hit) {
        let dmg = getPlayerDamage();
        if (crit) {
          dmg += getPlayerDamage();
          sfxCritical();
        } else {
          sfxHit();
        }
        dmg = Math.max(1, dmg);
        monster.curHp -= dmg;

        if (crit) {
          resultEl.textContent = 'CRITICAL! ' + dmg + ' DMG';
          resultEl.className = 'combat-result crit-result';
        } else {
          resultEl.textContent = 'HIT! ' + dmg + ' DMG';
          resultEl.className = 'combat-result hit';
        }
        updateCombatHP();

        const rollStr = `(${roll}${crit ? '!!' : ''} + ${mod} = ${total} vs AC ${monster.ac})`;
        if (monster.curHp <= 0) {
          addLog(`You strike the ${monster.name}! <span class="log-info">${rollStr}</span> <span class="log-damage">${dmg} dmg</span> \u2014 <span class="log-kill">SLAIN!</span>`);
          const xpGain = Math.floor(monster.xp * (player.race === 'human' ? 1.1 : 1));
          player.xp += xpGain;
          player.monstersKilled++;
          addLog(`<span class="log-xp">+${xpGain} XP</span>`);

          setTimeout(() => {
            resultEl.textContent = '\u2620 SLAIN! +' + xpGain + ' XP';
            resultEl.className = 'combat-result slain';
            sfxKill();
            setTimeout(() => endCombat('killed'), 1200);
          }, 400);
          return;
        } else {
          addLog(`You hit the ${monster.name}! <span class="log-info">${rollStr}</span> <span class="log-damage">${dmg} dmg</span> (${monster.curHp}/${monster.maxHp})`);
          logEl.innerHTML = `${monster.name}: ${monster.curHp}/${monster.maxHp} HP`;
        }
      } else {
        resultEl.textContent = 'MISS!';
        resultEl.className = 'combat-result miss-result';
        sfxMiss();
        addLog(`You miss the ${monster.name}. <span class="log-info">(${roll} + ${mod} = ${total} vs AC ${monster.ac})</span> <span class="log-miss">MISS</span>`);
      }

      // Monster counter-attack after delay
      if (monster.curHp > 0) {
        setTimeout(() => combatMonsterAttack(), 800);
      }
    }, 300);
  });
}

function combatMonsterAttack() {
  if (!combatMonster || combatMonster.curHp <= 0) return;
  combatPhase = 'monster_roll';
  const monster = combatMonster;

  document.getElementById('combat-result').textContent = '';
  document.getElementById('combat-result').className = 'combat-result';
  document.getElementById('combat-roll-math').textContent = '';
  document.getElementById('combat-log').innerHTML = `${monster.name} attacks!`;

  // Dragon breath weapon
  if (monster.special === 'breath' && Math.random() < 0.3) {
    animateDiceRoll(rand(1, 20), 600, () => {
      const save = rollDie(20) + statMod(player.stats.dex);
      const dmg = rollDice(4, 6, 0);
      const resultEl = document.getElementById('combat-result');
      document.getElementById('combat-roll-math').textContent = `DEX save: ${save} vs DC 15`;

      setTimeout(() => {
        if (save < 15) {
          player.hp -= dmg;
          resultEl.textContent = '\ud83d\udd25 BREATH! ' + dmg + ' DMG';
          resultEl.className = 'combat-result monster-hit';
          addLog(`<span class="log-player-hit">The ${monster.name} breathes fire! ${dmg} damage!</span>`);
        } else {
          const halfDmg = Math.floor(dmg / 2);
          player.hp -= halfDmg;
          resultEl.textContent = '\ud83d\udd25 BREATH! ' + halfDmg + ' DMG (saved)';
          resultEl.className = 'combat-result monster-hit';
          addLog(`<span class="log-player-hit">The ${monster.name} breathes fire! You dodge partially \u2014 ${halfDmg} damage!</span>`);
        }
        sfxPlayerHit();
        updateCombatHP();
        combatPhase = 'monster_result';
        finishMonsterTurn(monster);
      }, 300);
    });
    return;
  }

  // Normal monster attack
  const roll = rollDie(20);
  const total = roll + monster.atk;
  const hit = roll === 20 || (roll !== 1 && total >= player.ac);

  animateDiceRoll(roll, 600, () => {
    document.getElementById('combat-roll-math').textContent =
      `${roll} + ${monster.atk} = ${total} vs AC ${player.ac}`;

    setTimeout(() => {
      combatPhase = 'monster_result';
      const resultEl = document.getElementById('combat-result');

      if (hit) {
        let dmg = rollDmg(monster.dmg);
        if (roll === 20) dmg += rollDmg(monster.dmg);
        dmg = Math.max(1, dmg);
        player.hp -= dmg;

        if (roll === 20) {
          resultEl.textContent = 'CRITICAL! ' + dmg + ' DMG';
          resultEl.className = 'combat-result crit-result';
        } else {
          resultEl.textContent = monster.name.toUpperCase() + ' HITS! ' + dmg + ' DMG';
          resultEl.className = 'combat-result monster-hit';
        }
        sfxPlayerHit();
        addLog(`The ${monster.name} hits you! <span class="log-player-hit">${dmg} dmg</span> (HP: ${Math.max(0,player.hp)}/${player.maxHp})`);

        // Special effects
        const logEl = document.getElementById('combat-log');
        if (monster.special === 'poison' && Math.random() < 0.3) {
          const save = rollDie(20) + statMod(player.stats.con);
          if (save < 12 + player.floorLevel) {
            player.conditions.push({ type:'poisoned', duration: 5, dmg: 1 });
            logEl.innerHTML += '<br><span class="combat-special">You are poisoned!</span>';
            addLog(`<span class="log-player-hit">You are poisoned!</span>`);
          }
        }
        if (monster.special === 'drain') {
          const drainHp = rand(1, 3);
          monster.curHp = Math.min(monster.maxHp, monster.curHp + drainHp);
          logEl.innerHTML += '<br><span class="combat-special">Life force drained! (+' + drainHp + ' HP to ' + monster.name + ')</span>';
          addLog(`<span class="log-player-hit">The ${monster.name} drains your life force!</span>`);
        }
      } else {
        resultEl.textContent = monster.name.toUpperCase() + ' MISSES!';
        resultEl.className = 'combat-result miss-result';
        addLog(`The ${monster.name} misses you. <span class="log-miss">(${roll} + ${monster.atk} = ${total} vs AC ${player.ac})</span>`);
      }

      updateCombatHP();
      finishMonsterTurn(monster);
    }, 300);
  });
}

function finishMonsterTurn(monster) {
  // Check player death
  if (player.hp <= 0) {
    player.hp = 0;
    updateCombatHP();
    setTimeout(() => {
      endCombat('dead');
    }, 800);
    return;
  }

  // Ready for next round
  setTimeout(() => {
    const promptEl = document.getElementById('combat-prompt');
    promptEl.textContent = 'Press SPACE to attack \u2022 ESC to flee';
    promptEl.style.display = '';
    combatPhase = 'idle';
  }, 600);
}

function endCombat(result) {
  const overlay = document.getElementById('combat-overlay');
  overlay.classList.add('hidden');
  combatPhase = 'idle';

  if (result === 'killed') {
    // Warrior cleave check
    if (player.cls === 'warrior') {
      const adj = monsters.filter(m => m.curHp > 0 && Math.abs(m.x - player.x) <= 1 && Math.abs(m.y - player.y) <= 1);
      if (adj.length > 0) {
        addLog('<span class="log-kill">Cleave!</span>');
        // Start combat with the next adjacent monster
        setTimeout(() => startCombat(adj[0]), 300);
        return;
      }
    }

    combatMonster = null;
    gameState = GS.PLAYING;

    // Process rest of turn
    player.turnsPlayed++;
    processMonsterTurns();
    processConditions();
    processNaturalRegen();
    computeFOV(currentMap, player.x, player.y, player.visionRadius);
    renderAll();
    checkPlayerDeath();
    if (gameState === GS.PLAYING) checkLevelUp();

  } else if (result === 'dead') {
    combatMonster = null;
    gameState = GS.PLAYING;
    sfxDeath();
    gameState = GS.DEAD;
    showDeathScreen();

  } else if (result === 'fled') {
    combatMonster = null;
    gameState = GS.PLAYING;
    renderAll();
  }
}

function combatFlee() {
  if (combatAnimating) return;
  const monster = combatMonster;

  // Opportunity attack
  addLog(`<span class="log-info">You attempt to flee from the ${monster.name}!</span>`);

  // Monster gets a free attack (50% hit chance simplified)
  const roll = rollDie(20);
  const total = roll + monster.atk;
  const hit = roll === 20 || (roll !== 1 && total >= player.ac);
  if (hit) {
    let dmg = rollDmg(monster.dmg);
    dmg = Math.max(1, dmg);
    player.hp -= dmg;
    addLog(`<span class="log-player-hit">The ${monster.name} strikes as you flee! ${dmg} dmg</span>`);
    sfxPlayerHit();
  } else {
    addLog(`<span class="log-info">The ${monster.name} swings but misses as you flee!</span>`);
  }

  if (player.hp <= 0) {
    player.hp = 0;
    endCombat('dead');
    return;
  }

  // Move player away from monster if possible
  const dx = player.x - monster.x;
  const dy = player.y - monster.y;
  const nx = player.x + Math.sign(dx);
  const ny = player.y + Math.sign(dy);
  if (nx >= 0 && nx < MAP_W && ny >= 0 && ny < MAP_H &&
      currentMap[ny][nx].type !== TILE.WALL && !getMonsterAt(nx, ny)) {
    player.x = nx;
    player.y = ny;
  }

  endCombat('fled');

  // Still process the turn
  player.turnsPlayed++;
  processMonsterTurns();
  processConditions();
  processNaturalRegen();
  computeFOV(currentMap, player.x, player.y, player.visionRadius);
  renderAll();
  checkPlayerDeath();
}

function handleCombatInput(e) {
  if (combatAnimating) return;
  if (e.key === ' ' || e.key === 'Spacebar') {
    e.preventDefault();
    if (combatPhase === 'idle') {
      combatPlayerAttack();
    }
  } else if (e.key === 'Escape') {
    if (combatPhase === 'idle') {
      combatFlee();
    }
  }
}

// ════════════════════════════════════════════════════
// SECTION 14: PLAYER ACTIONS
// ════════════════════════════════════════════════════

function tryMove(dx, dy) {
  const nx = player.x + dx;
  const ny = player.y + dy;
  if (nx < 0 || nx >= MAP_W || ny < 0 || ny >= MAP_H) return false;

  const tile = currentMap[ny][nx];
  if (tile.type === TILE.WALL) return false;

  // Monster? Launch combat overlay instead of inline attack
  const monster = getMonsterAt(nx, ny);
  if (monster) {
    startCombat(monster);
    return false; // Don't process normal turn — combat handles it
  }

  // Move
  player.x = nx;
  player.y = ny;
  sfxStep();

  // Room description check
  for (let i = 1; i < currentRooms.length; i++) {
    const r = currentRooms[i];
    if (nx >= r.x && nx < r.x + r.w && ny >= r.y && ny < r.y + r.h) {
      const roomId = player.floorLevel + '_' + i;
      if (!visitedRooms.has(roomId) && Math.random() < 0.7) {
        visitedRooms.add(roomId);
        const tier = player.floorLevel <= 3 ? 0 : player.floorLevel <= 6 ? 1 : player.floorLevel <= 9 ? 2 : 3;
        addNarrative(pick(ROOM_DESCRIPTIONS[tier]));
      } else {
        visitedRooms.add(roomId);
      }
      // Environmental event check (separate from room descriptions, rarer)
      const envId = roomId + '_env';
      if (!visitedRooms.has(envId)) {
        visitedRooms.add(envId);
        if (Math.random() < 0.25) {
          const tier = player.floorLevel <= 3 ? 0 : player.floorLevel <= 6 ? 1 : player.floorLevel <= 9 ? 2 : 3;
          const evt = pick(ENVIRONMENTAL_EVENTS[tier]);
          sfxEnvironmental();
          addNarrative(evt.text);
          addLog(`<span class="log-info">${evt.log}</span>`);
          if (evt.effect) applyEnvironmentalEffect(evt.effect);
        }
      }
      break;
    }
  }

  // Trap?
  if (tile.type === TILE.TRAP && !tile.revealed) {
    // Rogue detects traps
    if (player.cls === 'rogue' && Math.random() < 0.5) {
      tile.revealed = true;
      addLog('<span class="log-info">You notice a trap and step around it.</span>');
    } else {
      tile.revealed = true;
      const save = rollDie(20) + statMod(player.stats.dex);
      const dc = 8 + Math.floor(player.floorLevel / 2);
      if (save >= dc) {
        addLog('<span class="log-info">You trigger a trap but leap aside! (DEX save ' + save + ' vs DC ' + dc + ')</span>');
      } else {
        const dmg = rollDice(1, 4, Math.floor(player.floorLevel / 2));
        player.hp -= dmg;
        addLog(`<span class="log-player-hit">TRAP! You take ${dmg} damage! (DEX save ${save} vs DC ${dc})</span>`);
        sfxPlayerHit();
      }
    }
  }

  return true;
}

function tryRest() {
  if (player.hp >= player.maxHp) {
    addLog('<span class="log-info">You are already at full health.</span>');
    renderAll();
    return;
  }
  // Check if any monsters are visible
  const nearbyMonster = monsters.find(m => m.curHp > 0 && currentMap[m.y][m.x].visible);
  if (nearbyMonster) {
    addLog('<span class="log-info">You cannot rest with enemies nearby!</span>');
    renderAll();
    return;
  }
  // Rest for several turns, healing each turn
  const restTurns = rand(5, 10);
  let healed = 0;
  let interrupted = false;
  for (let t = 0; t < restTurns; t++) {
    player.turnsPlayed++;
    processMonsterTurns();
    processConditions();
    computeFOV(currentMap, player.x, player.y, player.visionRadius);
    // Check if a monster wandered into view
    const threat = monsters.find(m => m.curHp > 0 && Math.abs(m.x - player.x) <= 1 && Math.abs(m.y - player.y) <= 1);
    if (threat) {
      addLog(`<span class="log-player-hit">Your rest is interrupted by a ${threat.name}!</span>`);
      interrupted = true;
      break;
    }
    // Heal 1 HP per rest turn
    if (player.hp < player.maxHp) {
      player.hp++;
      healed++;
    }
    if (player.hp >= player.maxHp) break;
  }
  if (!interrupted) {
    addLog(`<span class="log-item">You rest and recover ${healed} HP. (HP: ${player.hp}/${player.maxHp})</span>`);
  } else if (healed > 0) {
    addLog(`<span class="log-item">You recovered ${healed} HP before being disturbed.</span>`);
  }
  player.lastCombatTurn = player.turnsPlayed; // Reset regen timer after resting
  renderAll();
  checkPlayerDeath();
  if (gameState === GS.PLAYING) checkLevelUp();
}

function tryDescend() {
  if (currentMap[player.y][player.x].type !== TILE.STAIRS_DOWN) {
    addLog('<span class="log-info">There are no stairs here to descend.</span>');
    return false;
  }
  if (player.floorLevel >= MAX_FLOORS) return false;
  fadeTransition(() => enterFloor(player.floorLevel + 1, 'down'));
  return true;
}

function tryAscend() {
  if (currentMap[player.y][player.x].type !== TILE.STAIRS_UP) {
    addLog('<span class="log-info">There are no stairs here to ascend.</span>');
    return false;
  }
  if (player.floorLevel <= 1) {
    addLog('<span class="log-info">You cannot leave the dungeon. Your fate lies below.</span>');
    return false;
  }
  fadeTransition(() => enterFloor(player.floorLevel - 1, 'up'));
  return true;
}

function tryPickup() {
  const item = getItemAt(player.x, player.y);
  if (!item) {
    addLog('<span class="log-info">Nothing to pick up here.</span>');
    return false;
  }
  if (item.type === 'gold') {
    player.goldCollected += item.amount;
    addLog(`<span class="log-gold">You pick up ${item.amount} Bitcoin.</span>`);
    sfxGold();
  } else {
    if (player.inventory.length >= MAX_INVENTORY) {
      addLog('<span class="log-info">Your inventory is full!</span>');
      return false;
    }
    player.inventory.push(item);
    if (item.type === 'lore') {
      addLog(`<span class="log-item" style="color:#d4a857">You find a weathered journal: ${item.name}</span>`);
      addNarrative('You find a fragment of someone\'s journal, its pages yellowed and brittle...');
      sfxLoreOpen();
    } else {
      addLog(`<span class="log-item">You pick up: ${item.name}</span>`);
      sfxPickup();
    }
  }
  // Remove from floor
  const idx = items.indexOf(item);
  if (idx >= 0) items.splice(idx, 1);
  return true;
}

function applyEnvironmentalEffect(effect) {
  switch (effect) {
    case 'coin1':
      player.goldCollected += 1;
      addLog('<span class="log-gold">You pocket the coin. (+1 Bitcoin)</span>');
      sfxGold();
      break;
    case 'coin2':
      player.goldCollected += 2;
      addLog('<span class="log-gold">You pry the coin loose. (+2 Bitcoin)</span>');
      sfxGold();
      break;
    case 'coin3':
      player.goldCollected += 3;
      addLog('<span class="log-gold">You gather the fallen coins. (+3 Bitcoin)</span>');
      sfxGold();
      break;
    case 'chill':
      addLog('<span class="log-player-hit">A supernatural chill settles into your bones.</span>');
      break;
  }
}

// ════════════════════════════════════════════════════
// SECTION 15: CONDITIONS & LEVELING
// ════════════════════════════════════════════════════

function processConditions() {
  for (let i = player.conditions.length - 1; i >= 0; i--) {
    const c = player.conditions[i];
    if (c.type === 'poisoned') {
      player.hp -= c.dmg;
      addLog('<span class="log-player-hit">Poison courses through your veins... (-' + c.dmg + ' HP)</span>');
    }
    c.duration--;
    if (c.duration <= 0) {
      addLog('<span class="log-info">The ' + c.type + ' effect wears off.</span>');
      player.conditions.splice(i, 1);
    }
  }
}

function processNaturalRegen() {
  // Regenerate 1 HP every 10 turns when out of combat and not poisoned
  if (player.hp < player.maxHp &&
      player.turnsPlayed - player.lastCombatTurn >= 10 &&
      !player.conditions.some(c => c.type === 'poisoned') &&
      player.turnsPlayed % 10 === 0) {
    player.hp = Math.min(player.maxHp, player.hp + 1);
    addLog('<span class="log-info">You recover slightly. (+1 HP)</span>');
  }
}

function checkLevelUp() {
  if (player.xp >= player.xpToLevel) {
    player.level++;
    player.xp -= player.xpToLevel;
    player.xpToLevel = Math.floor(150 * player.level * 1.5);
    const hpGain = Math.max(1, rollDie(CLASSES[player.cls].hitDie) + statMod(player.stats.con));
    player.maxHp += hpGain;
    player.hp = player.maxHp;
    if (player.maxMana > 0) {
      player.maxMana += 2;
      player.mana = player.maxMana;
    }
    addLog(`<span class="log-kill">*** LEVEL UP! *** You are now level ${player.level}! (+${hpGain} HP)</span>`);
    sfxLevelUp();
    showLevelUp();
    return true;
  }
  return false;
}

function checkPlayerDeath() {
  if (player.hp <= 0) {
    player.hp = 0;
    sfxDeath();
    gameState = GS.DEAD;
    showDeathScreen();
  }
}

// ════════════════════════════════════════════════════
// SECTION 16: UI SCREENS
// ════════════════════════════════════════════════════

// Character Creation
function showCharCreate() {
  createStep = 0;
  createData = { name: '', race: null, cls: null, stats: null, rerolls: 3 };
  document.getElementById('charcreate-overlay').classList.remove('hidden');
  renderCreateStep();
}

function renderCreateStep() {
  const content = document.getElementById('create-content');
  const label = document.getElementById('create-step-label');
  const nav = document.getElementById('create-nav');

  if (createStep === 0) {
    label.textContent = 'Step 1: Name your hero';
    content.innerHTML = '<input class="name-input" id="name-input" type="text" maxlength="20" placeholder="Enter name..." autofocus>';
    nav.textContent = 'Press ENTER to continue';
    setTimeout(() => document.getElementById('name-input').focus(), 50);
  } else if (createStep === 1) {
    label.textContent = 'Step 2: Choose your race';
    let html = '<div class="create-options">';
    const keys = Object.keys(RACES);
    keys.forEach((key, i) => {
      const r = RACES[key];
      const mods = Object.entries(r.mods).filter(([,v]) => v !== 0).map(([k,v]) => k.toUpperCase() + ' ' + modStr(v)).join(', ');
      html += `<div class="create-option" data-key="${key}">
        <div class="opt-name">[${i+1}] ${r.name}</div>
        <div class="opt-desc">${r.desc}</div>
        <div class="opt-stats">${mods} — ${r.passive}</div>
      </div>`;
    });
    html += '</div>';
    content.innerHTML = html;
    nav.textContent = 'Press 1-4 to select';
  } else if (createStep === 2) {
    label.textContent = 'Step 3: Choose your class';
    let html = '<div class="create-options">';
    const keys = Object.keys(CLASSES);
    keys.forEach((key, i) => {
      const c = CLASSES[key];
      html += `<div class="create-option" data-key="${key}">
        <div class="opt-name">[${i+1}] ${c.name}</div>
        <div class="opt-desc">${c.desc}</div>
        <div class="opt-stats">Hit Die: d${c.hitDie} — ${c.ability}</div>
      </div>`;
    });
    html += '</div>';
    content.innerHTML = html;
    nav.textContent = 'Press 1-4 to select';
  } else if (createStep === 3) {
    label.textContent = 'Step 4: Roll your attributes';
    if (!createData.stats) {
      createData.stats = {};
      for (const s of ['str','dex','con','int','wis']) createData.stats[s] = roll4d6drop();
    }
    let html = '<div class="stat-roll-display">';
    for (const s of ['str','dex','con','int','wis']) {
      const v = createData.stats[s];
      const race = RACES[createData.race];
      const final = v + (race.mods[s] || 0);
      const m = statMod(final);
      const modCls = m >= 0 ? 'pos' : 'neg';
      html += `<div class="stat-box">
        <div class="stat-label">${s.toUpperCase()}</div>
        <div class="stat-value">${v}</div>
        <div class="stat-modifier ${modCls}" style="color:var(--${m >= 0 ? 'hp-full' : 'hp-danger'})">${race.mods[s] ? ' (' + modStr(race.mods[s]) + ' race)' : ''} → ${final} (${modStr(m)})</div>
      </div>`;
    }
    html += '</div>';
    html += `<div class="reroll-info">Press R to reroll (${createData.rerolls} remaining) — Press ENTER to accept</div>`;
    content.innerHTML = html;
    nav.textContent = '';
  }
}

function handleCharCreateInput(e) {
  if (createStep === 0) {
    if (e.key === 'Enter') {
      const input = document.getElementById('name-input');
      const name = input.value.trim();
      if (name.length === 0) return;
      createData.name = name;
      createStep = 1;
      renderCreateStep();
    }
  } else if (createStep === 1) {
    const keys = Object.keys(RACES);
    const idx = parseInt(e.key) - 1;
    if (idx >= 0 && idx < keys.length) {
      createData.race = keys[idx];
      createStep = 2;
      renderCreateStep();
    }
  } else if (createStep === 2) {
    const keys = Object.keys(CLASSES);
    const idx = parseInt(e.key) - 1;
    if (idx >= 0 && idx < keys.length) {
      createData.cls = keys[idx];
      createStep = 3;
      createData.stats = null;
      renderCreateStep();
    }
  } else if (createStep === 3) {
    if (e.key === 'r' || e.key === 'R') {
      if (createData.rerolls > 0) {
        createData.rerolls--;
        createData.stats = null;
        renderCreateStep();
      }
    } else if (e.key === 'Enter') {
      startGame();
    }
  }
}

function startGame() {
  document.getElementById('charcreate-overlay').classList.add('hidden');
  document.getElementById('game-layout').style.display = 'grid';

  player = createPlayer(createData.name, createData.race, createData.cls, createData.stats);
  floors = {};
  messageLog = [];
  document.getElementById('message-log').innerHTML = '';

  enterFloor(1, null);
  addLog('<span class="log-info">Welcome, ' + player.name + '. Your descent begins.</span>');
  addLog('<span class="log-info">Press M to toggle music.</span>');
  renderAll();
  startMusic(1);
  gameState = GS.PLAYING;
}

// Inventory screen
let inspectedItem = null;

function showInventory() {
  gameState = GS.INVENTORY;
  inspectedItem = null;
  document.getElementById('inv-detail').innerHTML = '<span class="detail-label">Press TAB + letter to inspect an item</span>';
  document.getElementById('inventory-overlay').classList.remove('hidden');
  renderInventory();
}

function getItemDescription(item) {
  let html = '';
  const isMagic = item.enchant && item.enchant > 0;
  html += `<div class="detail-name${isMagic ? ' magic' : ''}">${item.name}</div>`;

  if (item.type === 'weapon') {
    const dice = `${item.dmg[0]}d${item.dmg[1]}${item.dmg[2] ? '+' + item.dmg[2] : ''}`;
    const enchStr = item.enchant ? ` <span class="detail-highlight">+${item.enchant}</span>` : '';
    html += `<span class="detail-label">Damage:</span> <span class="detail-stat">${dice}${enchStr}</span>`;
    html += ` &nbsp; <span class="detail-label">Stat:</span> <span class="detail-stat">${item.stat.toUpperCase()}</span>`;
    html += `<br><span class="detail-label">Weight:</span> <span class="detail-stat">${item.weight}</span>`;
    html += ` &nbsp; <span class="detail-label">Value:</span> <span class="detail-stat">${item.value}</span>`;
    // Compare with equipped weapon
    const cur = player.equipment.weapon;
    if (cur && cur !== item) {
      const curDice = `${cur.dmg[0]}d${cur.dmg[1]}${cur.dmg[2] ? '+' + cur.dmg[2] : ''}`;
      html += `<br><span class="detail-compare">Equipped: ${cur.name} (${curDice}${cur.enchant ? ' +' + cur.enchant : ''})</span>`;
    }
  } else if (item.type === 'armor') {
    const enchStr = item.enchant ? ` <span class="detail-highlight">+${item.enchant}</span>` : '';
    html += `<span class="detail-label">AC Bonus:</span> <span class="detail-stat">+${item.acBonus}${enchStr}</span>`;
    html += ` &nbsp; <span class="detail-label">DEX Cap:</span> <span class="detail-stat">${item.dexCap >= 99 ? 'None' : '+' + item.dexCap}</span>`;
    html += `<br><span class="detail-label">Weight:</span> <span class="detail-stat">${item.weight}</span>`;
    html += ` &nbsp; <span class="detail-label">Value:</span> <span class="detail-stat">${item.value}</span>`;
    // Compare with equipped armor
    const cur = player.equipment.armor;
    if (cur && cur !== item) {
      html += `<br><span class="detail-compare">Equipped: ${cur.name} (AC +${cur.acBonus}${cur.enchant ? ' +' + cur.enchant : ''}, DEX cap ${cur.dexCap >= 99 ? 'None' : '+' + cur.dexCap})</span>`;
    }
  } else if (item.type === 'potion') {
    if (item.effect === 'heal') {
      const dice = `${item.amount[0]}d${item.amount[1]}+${item.amount[2]}`;
      html += `<span class="detail-label">Heals:</span> <span class="detail-stat">${dice} HP</span>`;
    } else if (item.effect === 'buff_str') {
      html += `<span class="detail-label">Effect:</span> <span class="detail-stat">+4 STR for ${item.duration} turns</span>`;
    } else if (item.effect === 'buff_dex') {
      html += `<span class="detail-label">Effect:</span> <span class="detail-stat">+4 DEX for ${item.duration} turns</span>`;
    }
    html += `<br><span class="detail-label">Value:</span> <span class="detail-stat">${item.value}</span>`;
  } else if (item.type === 'scroll') {
    if (item.effect === 'fireball') {
      const dice = `${item.damage[0]}d${item.damage[1]}`;
      html += `<span class="detail-label">Effect:</span> <span class="detail-stat">Fireball \u2014 ${dice} fire damage to all visible enemies</span>`;
    } else if (item.effect === 'teleport') {
      html += `<span class="detail-label">Effect:</span> <span class="detail-stat">Teleport to a random room</span>`;
    } else if (item.effect === 'reveal_map') {
      html += `<span class="detail-label">Effect:</span> <span class="detail-stat">Reveals the entire floor map</span>`;
    }
    html += `<br><span class="detail-label">Value:</span> <span class="detail-stat">${item.value}</span>`;
  } else if (item.type === 'lore') {
    html += `<div style="color:#d4a857;font-family:'Crimson Text',serif;font-style:italic;font-size:12px;margin-top:4px;">${item.title}</div>`;
    html += `<span class="detail-label">A journal fragment found on Floor ${item.floor}.</span>`;
    html += `<br><span class="detail-label" style="font-size:10px;">Select to read the full entry.</span>`;
  }

  return html;
}

// Build grouped inventory view — sorted by category, consumables stack by name,
// equipment always listed individually since enchantments can differ.
let invDisplayMap = []; // maps display index -> inventory index (first of that stack)

const INV_CATEGORIES = [
  { key: 'weapon', label: 'Weapons' },
  { key: 'armor',  label: 'Armor' },
  { key: 'potion', label: 'Potions' },
  { key: 'scroll', label: 'Scrolls' },
  { key: 'lore',   label: 'Journals' }
];

function buildInventoryStacks() {
  invDisplayMap = [];
  const categorized = {};
  const consumableCounts = {};

  // Bucket items by type
  player.inventory.forEach((item, i) => {
    const cat = item.type;
    if (!categorized[cat]) categorized[cat] = [];

    if (cat === 'potion' || cat === 'scroll') {
      if (consumableCounts[item.name] !== undefined) {
        consumableCounts[item.name].count++;
      } else {
        consumableCounts[item.name] = { item, firstIdx: i, count: 1 };
        categorized[cat].push({ item, firstIdx: i, type: 'stack', key: item.name, count: 1 });
      }
    } else {
      categorized[cat].push({ item, firstIdx: i, count: 1, type: 'single' });
    }
  });

  // Build final ordered list with category labels
  const result = [];
  for (const cat of INV_CATEGORIES) {
    const entries = categorized[cat.key];
    if (!entries || entries.length === 0) continue;
    // Resolve consumable counts
    for (const s of entries) {
      if (s.type === 'stack') s.count = consumableCounts[s.key].count;
    }
    result.push({ category: cat.label, entries });
  }

  // Build display map (flat list of real indices for key mapping)
  for (const group of result) {
    for (const s of group.entries) {
      invDisplayMap.push(s.firstIdx);
    }
  }

  return result;
}

function renderInventory() {
  const list = document.getElementById('inv-list');
  const footer = document.getElementById('inv-footer');

  if (player.inventory.length === 0) {
    list.innerHTML = '<div style="color:var(--text-faded);padding:8px;">Your pack is empty.</div>';
  } else {
    const groups = buildInventoryStacks();
    let html = '';
    let letterIdx = 0;
    for (const group of groups) {
      html += `<div class="inv-category">${group.category}</div>`;
      for (const s of group.entries) {
        const letter = String.fromCharCode(97 + letterIdx);
        const equipped = Object.values(player.equipment).includes(s.item);
        const inspecting = inspectedItem === s.item;
        const countStr = s.count > 1 ? ` <span style="color:var(--text-dim)">(x${s.count})</span>` : '';
        html += `<div class="inv-item" style="${inspecting ? 'background:var(--bg-surface);' : ''}">
          <span><span class="inv-key">${letter})</span> <span class="inv-name${equipped ? ' equipped' : ''}">${s.item.name}${countStr}${equipped ? ' (equipped)' : ''}</span></span>
        </div>`;
        letterIdx++;
      }
    }
    list.innerHTML = html;
  }
  footer.textContent = `${player.inventory.length}/${MAX_INVENTORY} — [a-t] use/equip — [TAB]+letter inspect — [x]+letter drop — [ESC] close`;
}

let inventoryDropMode = false;
let inventoryInspectMode = false;

function handleInventoryInput(e) {
  if (e.key === 'Escape') {
    inventoryDropMode = false;
    inventoryInspectMode = false;
    document.getElementById('inventory-overlay').classList.add('hidden');
    gameState = GS.PLAYING;
    return;
  }

  if (e.key === 'Tab') {
    e.preventDefault();
    inventoryInspectMode = !inventoryInspectMode;
    inventoryDropMode = false;
    const footer = document.getElementById('inv-footer');
    if (inventoryInspectMode) {
      footer.textContent = 'INSPECT MODE: press a-t to inspect an item — [TAB] cancel';
    } else {
      inspectedItem = null;
      document.getElementById('inv-detail').innerHTML = '<span class="detail-label">Press TAB + letter to inspect an item</span>';
      footer.textContent = `${player.inventory.length}/${MAX_INVENTORY} — [a-t] use/equip — [TAB]+letter inspect — [x]+letter drop — [ESC] close`;
      renderInventory();
    }
    return;
  }

  if (e.key === 'x') {
    inventoryDropMode = !inventoryDropMode;
    inventoryInspectMode = false;
    const footer = document.getElementById('inv-footer');
    if (inventoryDropMode) {
      footer.textContent = 'DROP MODE: press a-t to drop an item — [x] cancel';
    } else {
      footer.textContent = `${player.inventory.length}/${MAX_INVENTORY} — [a-t] use/equip — [TAB]+letter inspect — [x]+letter drop — [ESC] close`;
    }
    return;
  }

  const displayIdx = e.key.charCodeAt(0) - 97;
  if (displayIdx >= 0 && displayIdx < invDisplayMap.length) {
    const realIdx = invDisplayMap[displayIdx];
    const item = player.inventory[realIdx];
    if (inventoryInspectMode) {
      inspectedItem = item;
      document.getElementById('inv-detail').innerHTML = getItemDescription(item);
      inventoryInspectMode = false;
      const footer = document.getElementById('inv-footer');
      footer.textContent = `${player.inventory.length}/${MAX_INVENTORY} — [a-t] use/equip — [TAB]+letter inspect — [x]+letter drop — [ESC] close`;
      renderInventory();
      return;
    } else if (inventoryDropMode) {
      // Unequip if currently equipped
      for (const slot of ['weapon','armor','shield','ring','amulet']) {
        if (player.equipment[slot] === item) {
          player.equipment[slot] = null;
          recalcAC();
        }
      }
      // Place item on the ground at player's position
      item.x = player.x;
      item.y = player.y;
      items.push(item);
      player.inventory.splice(realIdx, 1);
      addLog(`<span class="log-info">You drop the ${item.name}.</span>`);
      inventoryDropMode = false;
    } else {
      useItem(item, realIdx);
    }
    renderInventory();
    renderStats();
  }
}

function useItem(item, idx) {
  if (item.type === 'potion') {
    if (item.effect === 'heal') {
      const healed = rollDmg(item.amount);
      player.hp = Math.min(player.maxHp, player.hp + healed);
      addLog(`<span class="log-item">You drink the ${item.name}. Healed ${healed} HP!</span>`);
    } else if (item.effect === 'buff_str') {
      player.conditions.push({ type: 'strengthened', duration: item.duration, stat: 'str', amount: 4 });
      player.stats.str += 4;
      addLog(`<span class="log-item">You drink the ${item.name}. You feel powerful!</span>`);
    } else if (item.effect === 'buff_dex') {
      player.conditions.push({ type: 'hastened', duration: item.duration, stat: 'dex', amount: 4 });
      player.stats.dex += 4;
      recalcAC();
      addLog(`<span class="log-item">You drink the ${item.name}. You feel swift!</span>`);
    }
    sfxPickup();
    player.inventory.splice(idx, 1);
  } else if (item.type === 'scroll') {
    if (item.effect === 'fireball') {
      // Damage all visible monsters
      let killed = 0;
      for (const m of monsters) {
        if (m.curHp > 0 && currentMap[m.y][m.x].visible) {
          const dmg = rollDmg(item.damage);
          m.curHp -= dmg;
          if (m.curHp <= 0) { killed++; player.monstersKilled++; player.xp += Math.floor(m.xp * (player.race === 'human' ? 1.1 : 1)); }
        }
      }
      addLog(`<span class="log-damage">Flames engulf the room! ${killed} monster(s) affected!</span>`);
    } else if (item.effect === 'teleport') {
      const room = pick(currentRooms);
      player.x = room.cx;
      player.y = room.cy;
      computeFOV(currentMap, player.x, player.y, player.visionRadius);
      addLog('<span class="log-item">Reality shifts — you teleport!</span>');
    } else if (item.effect === 'reveal_map') {
      for (let y = 0; y < MAP_H; y++)
        for (let x = 0; x < MAP_W; x++)
          currentMap[y][x].explored = true;
      addLog('<span class="log-item">The dungeon layout burns into your mind!</span>');
    }
    sfxPickup();
    player.inventory.splice(idx, 1);
    document.getElementById('inventory-overlay').classList.add('hidden');
    gameState = GS.PLAYING;
    renderAll();
  } else if (item.type === 'weapon') {
    if (player.equipment.weapon === item) {
      player.equipment.weapon = null;
      addLog('<span class="log-info">You unequip the ' + item.name + '.</span>');
    } else {
      player.equipment.weapon = item;
      addLog('<span class="log-item">You equip the ' + item.name + '.</span>');
    }
  } else if (item.type === 'armor') {
    if (player.equipment.armor === item) {
      player.equipment.armor = null;
      recalcAC();
      addLog('<span class="log-info">You remove the ' + item.name + '.</span>');
    } else {
      player.equipment.armor = item;
      recalcAC();
      addLog('<span class="log-item">You don the ' + item.name + '.</span>');
    }
  } else if (item.type === 'lore') {
    showLoreOverlay(item);
  }
}

function showLoreOverlay(item) {
  currentLoreItem = item;
  gameState = GS.LORE;
  document.getElementById('inventory-overlay').classList.add('hidden');
  const overlay = document.getElementById('lore-overlay');
  overlay.classList.remove('hidden');
  document.getElementById('lore-title').textContent = item.title;

  // Typewriter effect for the lore text
  const textEl = document.getElementById('lore-text');
  textEl.textContent = '';
  let i = 0;
  const fullText = item.text;
  function typeLore() {
    if (i < fullText.length) {
      textEl.textContent += fullText[i++];
      loreTimer = setTimeout(typeLore, 18 + Math.random() * 12);
    }
  }
  sfxLoreOpen();
  typeLore();
}

function closeLoreOverlay() {
  if (loreTimer) { clearTimeout(loreTimer); loreTimer = null; }
  document.getElementById('lore-overlay').classList.add('hidden');
  currentLoreItem = null;
  gameState = GS.INVENTORY;
  showInventory();
}

// Help screen
function showHelp() {
  gameState = GS.HELP;
  document.getElementById('help-overlay').classList.remove('hidden');
  document.getElementById('help-content').innerHTML = `
    <div class="help-section"><h3>MOVEMENT</h3>
      <div class="help-row"><kbd>Arrows/hjkl</kbd><span>Cardinal movement</span></div>
      <div class="help-row"><kbd>y u b n</kbd><span>Diagonal movement</span></div>
      <div class="help-row"><kbd>7 8 9 4 6 1 2 3</kbd><span>Numpad movement</span></div>
      <div class="help-row"><kbd>. / 5</kbd><span>Wait one turn</span></div>
    </div>
    <div class="help-section"><h3>ACTIONS</h3>
      <div class="help-row"><kbd>g / ,</kbd><span>Pick up item</span></div>
      <div class="help-row"><kbd>r</kbd><span>Rest (heal when no enemies near)</span></div>
      <div class="help-row"><kbd>&gt;</kbd><span>Descend stairs</span></div>
      <div class="help-row"><kbd>&lt;</kbd><span>Ascend stairs</span></div>
      <div class="help-row"><kbd>i</kbd><span>Open inventory</span></div>
      <div class="help-row"><kbd>m</kbd><span>Toggle music</span></div>
      <div class="help-row"><kbd>?</kbd><span>This help screen</span></div>
    </div>
    <div class="help-section"><h3>COMBAT</h3>
      <div class="help-row"><kbd>Move into</kbd><span>Engage a monster (opens combat)</span></div>
      <div class="help-row"><kbd>SPACE</kbd><span>Attack in combat</span></div>
      <div class="help-row"><kbd>ESC</kbd><span>Flee from combat</span></div>
    </div>
    <div style="margin-top:12px;color:var(--text-faded);font-size:11px;">Press ESC or ? to close</div>
  `;
}

// Level-up screen
function showLevelUp() {
  gameState = GS.LEVEL_UP;
  document.getElementById('levelup-overlay').classList.remove('hidden');
  document.getElementById('lu-info').textContent = `You have reached level ${player.level}! Choose a stat to improve:`;
  let html = '<div class="create-options">';
  const stats = ['str','dex','con','int','wis'];
  stats.forEach((s, i) => {
    html += `<div class="create-option" data-key="${s}">
      <div class="opt-name">[${i+1}] ${s.toUpperCase()}: ${player.stats[s]} → ${player.stats[s] + 1}</div>
    </div>`;
  });
  html += '</div>';
  document.getElementById('lu-content').innerHTML = html;
}

function handleLevelUpInput(e) {
  const idx = parseInt(e.key) - 1;
  const stats = ['str','dex','con','int','wis'];
  if (idx >= 0 && idx < stats.length) {
    player.stats[stats[idx]]++;
    recalcAC();
    addLog('<span class="log-kill">' + stats[idx].toUpperCase() + ' increased to ' + player.stats[stats[idx]] + '!</span>');
    document.getElementById('levelup-overlay').classList.add('hidden');
    gameState = GS.PLAYING;
    renderAll();
  }
}

// Death screen
function showDeathScreen() {
  stopMusic();
  document.getElementById('game-layout').style.display = 'none';
  document.getElementById('death-overlay').classList.remove('hidden');

  const cause = 'the dungeon';
  const lastMonster = monsters.find(m => m.curHp > 0 && Math.abs(m.x - player.x) <= 2 && Math.abs(m.y - player.y) <= 2);
  const killer = lastMonster ? lastMonster.name : 'the darkness';
  const score = player.monstersKilled * 10 + player.goldCollected + player.deepestFloor * 100 + player.level * 50;

  const tomb = `
          ___________
         /           \\
        /   R.I.P.    \\
       /               \\
      |  ${player.name.padEnd(16)}|
      |  ${(RACES[player.race].name + ' ' + CLASSES[player.cls].name).padEnd(16)}|
      |  Level ${String(player.level).padEnd(9)}|
      |                |
      |  Slain by      |
      |  ${killer.padEnd(14)}|
      |  on floor ${String(player.floorLevel).padEnd(5)}|
      |                |
      |  Turns: ${String(player.turnsPlayed).padEnd(7)}|
      |  Kills: ${String(player.monstersKilled).padEnd(7)}|
      |  BTC:   ${String(player.goldCollected).padEnd(7)}|
      |                |
       \\  Score: ${String(score).padEnd(6)}/
        \\______________/
              | |
          ____|_|____
         |__________|`;

  document.getElementById('tombstone-art').textContent = tomb;

  // Save high score
  const scores = JSON.parse(localStorage.getItem('deep_scores') || '[]');
  scores.push({ name: player.name, score, level: player.level, floor: player.deepestFloor, race: player.race, cls: player.cls });
  scores.sort((a, b) => b.score - a.score);
  scores.splice(10);
  localStorage.setItem('deep_scores', JSON.stringify(scores));
}

// ════════════════════════════════════════════════════
// SECTION 17: INPUT HANDLING
// ════════════════════════════════════════════════════

function handleInput(e) {
  initAudio();

  switch (gameState) {
    case GS.TITLE:
      if (e.key === 'Enter') {
        document.getElementById('title-overlay').classList.add('hidden');
        showCharCreate();
        gameState = GS.CHAR_CREATE;
      }
      break;

    case GS.CHAR_CREATE:
      handleCharCreateInput(e);
      break;

    case GS.PLAYING:
      handlePlayingInput(e);
      break;

    case GS.INVENTORY:
      handleInventoryInput(e);
      break;

    case GS.HELP:
      if (e.key === 'Escape' || e.key === '?') {
        document.getElementById('help-overlay').classList.add('hidden');
        gameState = GS.PLAYING;
      }
      break;

    case GS.LORE:
      if (e.key === 'Escape' || e.key === 'Enter') {
        closeLoreOverlay();
      } else if (e.key === ' ') {
        // Space — skip typewriter, show full text
        if (loreTimer) { clearTimeout(loreTimer); loreTimer = null; }
        if (currentLoreItem) {
          document.getElementById('lore-text').textContent = currentLoreItem.text;
        }
      }
      break;

    case GS.LEVEL_UP:
      handleLevelUpInput(e);
      break;

    case GS.COMBAT:
      handleCombatInput(e);
      break;

    case GS.DEAD:
      if (e.key === 'Enter') {
        document.getElementById('death-overlay').classList.add('hidden');
        document.getElementById('title-overlay').classList.remove('hidden');
        gameState = GS.TITLE;
      }
      break;
  }
}

function handlePlayingInput(e) {
  let acted = false;

  switch (e.key) {
    case 'ArrowUp':    case 'k': case '8': acted = tryMove(0, -1); break;
    case 'ArrowDown':  case 'j': case '2': acted = tryMove(0, 1);  break;
    case 'ArrowLeft':  case 'h': case '4': acted = tryMove(-1, 0); break;
    case 'ArrowRight': case 'l': case '6': acted = tryMove(1, 0);  break;
    case 'y': case '7': acted = tryMove(-1, -1); break;
    case 'u': case '9': acted = tryMove(1, -1);  break;
    case 'b': case '1': acted = tryMove(-1, 1);  break;
    case 'n': case '3': acted = tryMove(1, 1);   break;
    case '.': case '5': acted = true; break; // Wait
    case 'r': tryRest(); return;
    case '>': acted = tryDescend(); break;
    case '<': acted = tryAscend(); break;
    case 'g': case ',': acted = tryPickup(); break;
    case 'i': showInventory(); return;
    case 'm': toggleMusic(); return;
    case '?': showHelp(); return;
    default: return;
  }

  if (acted) {
    player.turnsPlayed++;
    processMonsterTurns();
    processConditions();
    processNaturalRegen();
    computeFOV(currentMap, player.x, player.y, player.visionRadius);
    renderAll();
    checkPlayerDeath();
    if (gameState === GS.PLAYING) checkLevelUp();
  }
}

// ════════════════════════════════════════════════════
// SECTION 18: INITIALIZATION
// ════════════════════════════════════════════════════

document.addEventListener('keydown', handleInput);

})();
</script>
</body>
</html>
